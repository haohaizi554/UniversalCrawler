# app/core/download_manager.py

import os
import threading
import queue
from PyQt6.QtCore import QThread, pyqtSignal, QObject, QSemaphore
from app.models import VideoItem
from app.core.downloaders import KuaishouDownloader, MissAVDownloader, BilibiliDownloader

class DownloadWorker(QThread):
    sig_start = pyqtSignal(str)
    sig_progress = pyqtSignal(str, int)
    sig_finished = pyqtSignal(str)
    sig_error = pyqtSignal(str, str)

    def __init__(self, video: VideoItem, save_dir: str, semaphore: QSemaphore):
        super().__init__()
        self.video = video
        self.save_dir = save_dir
        self.semaphore = semaphore
        self.is_running = True

    def run(self):
        self.semaphore.acquire()
        try:
            if not self.is_running: return
            self.sig_start.emit(self.video.id)
            if not os.path.exists(self.save_dir):
                os.makedirs(self.save_dir, exist_ok=True)
            # è·å–æ–‡ä»¶å
            filename = self.video.get_safe_filename("mp4")
            filepath = os.path.join(self.save_dir, filename)
            self.video.local_path = filepath
            # ç­–ç•¥é€‰æ‹©
            downloader = None
            if self.video.source == "kuaishou":
                downloader = KuaishouDownloader()
            elif self.video.source == "missav":
                downloader = MissAVDownloader()
            elif self.video.source == "bilibili":
                downloader = BilibiliDownloader()
            else:
                raise ValueError(f"Unknown source: {self.video.source}")
            # æ‰§è¡Œä¸‹è½½ (ä¼ å…¥å›è°ƒå’Œåœæ­¢æ£€æŸ¥)
            downloader.download(
                video_item=self.video,
                save_path=filepath,
                progress_callback=lambda p: self.sig_progress.emit(self.video.id, p),
                check_stop_func=lambda: not self.is_running
            )
            if self.is_running:
                self.sig_finished.emit(self.video.id)
        except InterruptedError:
            self.sig_error.emit(self.video.id, "ç”¨æˆ·å·²åœæ­¢")
        except Exception as e:
            self.sig_error.emit(self.video.id, str(e))
        finally:
            self.semaphore.release()
    def stop(self):
        self.is_running = False

class DownloadManager(QObject):
    task_started = pyqtSignal(str)
    task_progress = pyqtSignal(str, int)
    task_finished = pyqtSignal(str)
    task_error = pyqtSignal(str, str)
    def __init__(self, max_concurrent=3):
        super().__init__()
        self.queue = queue.Queue()
        self.workers = []
        self.max_concurrent = max_concurrent
        self.semaphore = QSemaphore(max_concurrent)
        self.is_running = True
        self.dispatcher_thread = threading.Thread(target=self._dispatch_loop, daemon=True)
        self.dispatcher_thread.start()
    def add_task(self, video: VideoItem, save_dir: str):
        self.queue.put((video, save_dir))
    def _dispatch_loop(self):
        while self.is_running:
            try:
                video, save_dir = self.queue.get(timeout=1)
                self.workers = [w for w in self.workers if w.isRunning()]
                worker = DownloadWorker(video, save_dir, self.semaphore)
                worker.sig_start.connect(self.task_started)
                worker.sig_progress.connect(self.task_progress)
                worker.sig_finished.connect(self.task_finished)
                worker.sig_error.connect(self.task_error)
                self.workers.append(worker)
                worker.start()
            except queue.Empty:
                continue
            except Exception as e:
                print(f"Dispatcher Error: {e}")
    def stop_all(self):
        self.is_running = False
        # æ¸…ç©ºé˜Ÿåˆ—
        while not self.queue.empty():
            try:
                self.queue.get_nowait()
            except:
                pass
        # åœæ­¢æ‰€æœ‰æ­£åœ¨è¿è¡Œçš„å·¥å…µ
        for w in self.workers:
            w.stop()
            w.wait()


# app/core/downloaders.py

import os
import time
import requests
import subprocess
import signal

class BaseDownloader:
    def download(self, video_item, save_path, progress_callback, check_stop_func):
        raise NotImplementedError

class KuaishouDownloader(BaseDownloader):
    def download(self, video_item, save_path, progress_callback, check_stop_func):
        # ä¿æŒå¿«æ‰‹ä¸‹è½½é€»è¾‘ä¸å˜ï¼Œå› ä¸ºå®ƒç”¨çš„æ˜¯ requestsï¼Œä¸”éœ€è¦ cookie
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Referer": video_item.meta.get("referer", "https://www.kuaishou.com/")
        }
        if "cookies" in video_item.meta:
            cookie_dict = video_item.meta["cookies"]
            if isinstance(cookie_dict, dict):
                headers["Cookie"] = "; ".join([f"{k}={v}" for k, v in cookie_dict.items()])
        temp_path = save_path + ".downloading"
        max_retries = 3
        success = False
        for attempt in range(max_retries):
            if check_stop_func(): break
            try:
                with requests.get(video_item.url, headers=headers, stream=True, timeout=60) as r:
                    r.raise_for_status()
                    total_size = int(r.headers.get('content-length', 0))
                    downloaded = 0
                    with open(temp_path, 'wb') as f:
                        for chunk in r.iter_content(chunk_size=8192):
                            if check_stop_func(): raise InterruptedError("ç”¨æˆ·åœæ­¢ä¸‹è½½")
                            if chunk:
                                f.write(chunk)
                                downloaded += len(chunk)
                                if total_size > 0:
                                    percent = int((downloaded / total_size) * 100)
                                    if downloaded % (8192 * 100) == 0 or percent == 100:
                                        progress_callback(percent)
                success = True
                break
            except InterruptedError:
                break
            except Exception as e:
                print(f"âš ï¸ [Kuaishou] ä¸‹è½½ä¸­æ–­: {e}")
                time.sleep(3)
        if success:
            if os.path.exists(save_path):
                try:
                    os.remove(save_path)
                except:
                    pass
            os.rename(temp_path, save_path)
            progress_callback(100)
        else:
            if os.path.exists(temp_path):
                try:
                    os.remove(temp_path)
                except:
                    pass
            if not check_stop_func():
                raise Exception("ä¸‹è½½å¤±è´¥")

class MissAVDownloader(BaseDownloader):
    def download(self, video_item, save_path, progress_callback, check_stop_func):
        exe_path = "N_m3u8DL-RE.exe"
        if not os.path.exists(exe_path):
            raise FileNotFoundError("æœªæ‰¾åˆ° N_m3u8DL-RE.exe")

        m3u8_url = video_item.url
        ua = video_item.meta.get("ua", "Mozilla/5.0")
        referer = video_item.meta.get("referer", "https://missav.ai/")

        save_dir = os.path.dirname(save_path)
        save_name_no_ext = os.path.splitext(os.path.basename(save_path))[0]

        cmd = [
            exe_path,
            m3u8_url,
            "--save-dir", save_dir,
            "--save-name", save_name_no_ext,
            "--thread-count", "16",
            "--download-retry-count", "10",
            "--auto-select", "true",
            "--header", f"User-Agent: {ua}",
            "--header", f"Referer: {referer}",
            "--mux-after-done", "format=mp4"
        ]

        creation_flags = 0
        if os.name == 'nt':
            creation_flags = subprocess.CREATE_NEW_CONSOLE
        progress_callback(10)
        try:
            # å¯åŠ¨å¤–éƒ¨è¿›ç¨‹
            process = subprocess.Popen(cmd, creationflags=creation_flags)
            # å¾ªç¯æ£€æŸ¥è¿›ç¨‹çŠ¶æ€
            while process.poll() is None:
                if check_stop_func():
                    process.kill()
                    raise InterruptedError("ç”¨æˆ·åœæ­¢ä¸‹è½½")
                time.sleep(1)
                # ä¿æŒåœ¨50%ç›´åˆ°å®Œæˆï¼Œç”¨æˆ·çœ‹å¼¹çª—è¿›åº¦
                progress_callback(50)
            if process.returncode != 0:
                raise Exception(f"å¤–éƒ¨ä¸‹è½½å™¨å¼‚å¸¸é€€å‡º (Code: {process.returncode})")
            progress_callback(100)
        except Exception as e:
            raise e


class BilibiliDownloader(BaseDownloader):
    def download(self, video_item, save_path, progress_callback, check_stop_func):
        # 1. æ£€æŸ¥ ffmpeg
        ffmpeg_path = "ffmpeg.exe"
        if not os.path.exists(ffmpeg_path):
            # å°è¯•ç³»ç»Ÿè·¯å¾„
            try:
                subprocess.run(["ffmpeg", "-version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                ffmpeg_path = "ffmpeg"
            except:
                raise FileNotFoundError("æœªæ‰¾åˆ° ffmpeg.exeï¼Œæ— æ³•åˆå¹¶éŸ³è§†é¢‘")
        video_url = video_item.url
        audio_url = video_item.meta.get("audio_url")
        headers = {
            "User-Agent": video_item.meta.get("ua", "Mozilla/5.0"),
            "Referer": video_item.meta.get("referer", "https://www.bilibili.com")
        }
        save_dir = os.path.dirname(save_path)
        base_name = os.path.splitext(os.path.basename(save_path))[0]
        # ä¸´æ—¶æ–‡ä»¶è·¯å¾„
        temp_v = os.path.join(save_dir, f"{base_name}_video.m4s")
        temp_a = os.path.join(save_dir, f"{base_name}_audio.m4s")
        # 2. ä¸‹è½½å‡½æ•°
        def download_stream(url, path):
            if not url: return False
            try:
                with requests.get(url, headers=headers, stream=True, timeout=60) as r:
                    r.raise_for_status()
                    total = int(r.headers.get('content-length', 0))
                    downloaded = 0
                    with open(path, 'wb') as f:
                        for chunk in r.iter_content(chunk_size=8192):
                            if check_stop_func(): raise InterruptedError
                            if chunk:
                                f.write(chunk)
                                downloaded += len(chunk)
                                # ç®€å•ä¼°ç®—è¿›åº¦ (åªæ±‡æŠ¥è§†é¢‘æµçš„)
                                if ".m4s" in path and total > 0:
                                    progress_callback(int((downloaded / total) * 80))  # é¢„ç•™20%ç»™åˆå¹¶
                return True
            except Exception as e:
                if os.path.exists(path): os.remove(path)
                raise e
        # 3. æ‰§è¡Œä¸‹è½½
        progress_callback(10)
        try:
            # ä¸‹è½½è§†é¢‘
            download_stream(video_url, temp_v)
            # ä¸‹è½½éŸ³é¢‘ (å¦‚æœæœ‰)
            has_audio = False
            if audio_url:
                progress_callback(85)
                download_stream(audio_url, temp_a)
                has_audio = True
            # 4. åˆå¹¶ (Merge)
            progress_callback(90)
            cmd_merge = [ffmpeg_path, "-y", "-i", temp_v]
            if has_audio:
                cmd_merge.extend(["-i", temp_a])
            # copyæµï¼Œæ— éœ€è½¬ç ï¼Œé€Ÿåº¦æå¿«
            cmd_merge.extend(["-c", "copy", save_path])
            # éšè—é»‘æ¡†æ‰§è¡Œ
            startupinfo = None
            if os.name == 'nt':
                startupinfo = subprocess.STARTUPINFO()
                startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW
            subprocess.run(
                cmd_merge,
                check=True,
                startupinfo=startupinfo,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
            # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
            try:
                if os.path.exists(temp_v): os.remove(temp_v)
                if os.path.exists(temp_a): os.remove(temp_a)
            except:
                pass
            progress_callback(100)
        except InterruptedError:
            # æ¸…ç†åƒåœ¾
            if os.path.exists(temp_v): os.remove(temp_v)
            if os.path.exists(temp_a): os.remove(temp_a)
            raise InterruptedError("ç”¨æˆ·åœæ­¢ä¸‹è½½")
        except Exception as e:
            # æ¸…ç†åƒåœ¾
            if os.path.exists(temp_v): os.remove(temp_v)
            if os.path.exists(temp_a): os.remove(temp_a)
            raise Exception(f"Bç«™ä¸‹è½½å¤±è´¥: {e}")


# app/core/registry.py

from PyQt6.QtWidgets import QWidget, QHBoxLayout, QCheckBox, QComboBox, QLabel, QSpinBox
from app.utils import cfg
# å»¶è¿Ÿå¯¼å…¥æˆ–ç›´æ¥å¯¼å…¥çˆ¬è™«ç±»
from app.spiders.kuaishou_spider import KuaishouSpider
from app.spiders.missav_spider import MissAVSpider
from app.spiders.bilibili_spider import BilibiliSpider

class BasePlugin:
    id = "base"
    name = "Base Plugin"
    def get_search_placeholder(self) -> str:
        return "è¯·è¾“å…¥å…³é”®è¯..."
    def get_settings_widget(self, parent=None) -> QWidget:
        return None
    def get_spider_class(self):
        raise NotImplementedError
    def get_run_options(self, settings_widget: QWidget) -> dict:
        return {}

class KuaishouPlugin(BasePlugin):
    id = "kuaishou"
    name = "å¿«æ‰‹"
    def get_search_placeholder(self) -> str:
        return "è¾“å…¥å¿«æ‰‹å·æˆ–å…³é”®è¯..."
    def get_settings_widget(self, parent=None) -> QWidget:
        return None
    def get_spider_class(self):
        return KuaishouSpider
    def get_run_options(self, settings_widget: QWidget) -> dict:
        return {}

class MissAVPlugin(BasePlugin):
    id = "missav"
    name = "MissAV"
    def get_search_placeholder(self) -> str:
        return "è¾“å…¥ç•ªå· (å¦‚ IPX-906) æˆ–å¥³ä¼˜å..."
    def get_settings_widget(self, parent=None) -> QWidget:
        container = QWidget(parent)
        layout = QHBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(10)
        # 1. ä»…å•ä½“
        self.chk_individual = QCheckBox("ä»…å•ä½“")
        self.chk_individual.setChecked(cfg.get("missav", "individual_only", False))
        layout.addWidget(self.chk_individual)
        # 2. æ’åº (ç²¾ç®€é€‰é¡¹)
        self.combo_priority = QComboBox()
        # åªä¿ç•™ä¸¤ä¸ªæœ‰æ•ˆé€‰é¡¹
        self.combo_priority.addItems(["ä¸­æ–‡å­—å¹•ä¼˜å…ˆ", "æ— ç æµå‡ºä¼˜å…ˆ"])
        # è·å–é…ç½®ï¼Œå¦‚æœé…ç½®æ˜¯æ—§çš„"é»˜è®¤æ’åº"ï¼Œåˆ™å¼ºåˆ¶è½¬ä¸º"ä¸­æ–‡å­—å¹•ä¼˜å…ˆ"
        saved_priority = cfg.get("missav", "priority", "ä¸­æ–‡å­—å¹•ä¼˜å…ˆ")
        if saved_priority == "é»˜è®¤æ’åº":
            saved_priority = "ä¸­æ–‡å­—å¹•ä¼˜å…ˆ"
        self.combo_priority.setCurrentText(saved_priority)
        layout.addWidget(self.combo_priority)
        # 3. ä»£ç†
        layout.addWidget(QLabel("ä»£ç†:"))
        self.combo_proxy = QComboBox()
        self.combo_proxy.addItems(["Clash (7890)", "v2rayN (10809)", "è‡ªå®šä¹‰"])
        self.combo_proxy.setEditable(True)
        self.combo_proxy.setCurrentText(cfg.get("missav", "proxy_app", "Clash (7890)"))
        self.combo_proxy.setMinimumWidth(110)
        layout.addWidget(self.combo_proxy)
        return container
    def get_spider_class(self):
        return MissAVSpider
    def get_run_options(self, widget: QWidget) -> dict:
        if not widget:
            return {
                "individual_only": False,
                "priority": "ä¸­æ–‡å­—å¹•ä¼˜å…ˆ",
                "proxy": "http://127.0.0.1:7890"
            }
        # æå–æ•°æ®
        is_individual = self.chk_individual.isChecked()
        priority = self.combo_priority.currentText()
        proxy_str = self.combo_proxy.currentText()
        proxy_url = "http://127.0.0.1:7890"
        if "7890" in proxy_str:
            proxy_url = "http://127.0.0.1:7890"
        elif "10809" in proxy_str:
            proxy_url = "http://127.0.0.1:10809"
        elif ":" in proxy_str:
            proxy_url = proxy_str if proxy_str.startswith("http") else f"http://{proxy_str}"
        # ä¿å­˜å› config.json
        cfg.set("missav", "individual_only", is_individual)
        cfg.set("missav", "priority", priority)
        cfg.update_missav_proxy(proxy_str, proxy_url)
        return {
            "individual_only": is_individual,
            "priority": priority,
            "proxy": proxy_url
        }

class BilibiliPlugin(BasePlugin):
    id = "bilibili"
    name = "Bilibili"
    def get_search_placeholder(self) -> str:
        return "BVå·ï¼ˆå…¼å®¹åˆé›†ï¼‰ / UPä¸»å / å…³é”®è¯..."
    def get_settings_widget(self, parent=None) -> QWidget:
        container = QWidget(parent)
        layout = QHBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(10)
        layout.addWidget(QLabel("çˆ¬å–é¡µæ•°:"))
        self.spin_pages = QSpinBox()
        self.spin_pages.setRange(1, 500)
        self.spin_pages.setValue(1)
        self.spin_pages.setToolTip("æœç´¢æˆ–åˆ—è¡¨æ‰«æçš„æœ€å¤§é¡µæ•°")
        layout.addWidget(self.spin_pages)
        info = QLabel("ğŸ”’ è‡ªåŠ¨ç™»å½• | ğŸ“º æœ€ä¼˜ç”»è´¨")
        info.setStyleSheet("color: #00AEEC; font-weight: bold;")
        layout.addWidget(info)
        return container
    def get_spider_class(self):
        from app.spiders.bilibili_spider import BilibiliSpider
        return BilibiliSpider
    def get_run_options(self, widget: QWidget) -> dict:
        # ç¡®ä¿è·å–åˆ°çš„æ˜¯å½“å‰ UI ä¸Šçš„å€¼
        pages = 1
        try:
            if hasattr(self, 'spin_pages'):
                pages = self.spin_pages.value()
        except:
            pass
        return {"max_pages": pages}

class PluginRegistry:
    def __init__(self):
        self._plugins = {}
        self.register(KuaishouPlugin())
        self.register(MissAVPlugin())
        self.register(BilibiliPlugin())
    def register(self, plugin: BasePlugin):
        self._plugins[plugin.id] = plugin
    def get_all_plugins(self):
        return list(self._plugins.values())
    def get_plugin(self, plugin_id) -> BasePlugin:
        return self._plugins.get(plugin_id)
registry = PluginRegistry()


# app/spiders/base_spider.py
import threading
from PyQt6.QtCore import QThread, pyqtSignal
from app.models import VideoItem, AppConfig

class BaseSpider(QThread):
    # åŸºç¡€ä¿¡å·
    sig_log = pyqtSignal(str)
    sig_item_found = pyqtSignal(VideoItem)
    sig_finished = pyqtSignal()
    # å‚æ•°: (list) åŒ…å«æ ‡é¢˜çš„å­—å…¸åˆ—è¡¨
    sig_select_tasks = pyqtSignal(list)
    def __init__(self, keyword: str, config: dict):
        super().__init__()
        self.keyword = keyword
        self.config = config
        self.is_running = True
        # åŒæ­¥é”ï¼Œç”¨äºæš‚åœçˆ¬è™«ç­‰å¾…UIå“åº”
        self._resume_event = threading.Event()
        self._selection_result = None  # å­˜å‚¨ç”¨æˆ·è¿”å›çš„ç´¢å¼•åˆ—è¡¨
    def stop(self):
        self.is_running = False
        self._resume_event.set()  # é˜²æ­¢å¡æ­»åœ¨ç­‰å¾…ä¸­
        self.sig_log.emit("ğŸ›‘ æ­£åœ¨åœæ­¢ä»»åŠ¡...")
    def run(self):
        raise NotImplementedError("å­ç±»å¿…é¡»å®ç° run æ–¹æ³•")
    # ================= è¾…åŠ©æ–¹æ³• =================
    def log(self, msg: str):
        self.sig_log.emit(msg)
    def emit_video(self, url: str, title: str, source: str, meta: dict = None):
        item = VideoItem(url=url, title=title, source=source)
        if meta: item.meta = meta
        self.sig_item_found.emit(item)
    def ask_user_selection(self, items: list) -> list:
        # [æ ¸å¿ƒå‡çº§] é˜»å¡å½“å‰çˆ¬è™«çº¿ç¨‹ï¼Œç­‰å¾…ä¸»çº¿ç¨‹(UI)çš„ç”¨æˆ·é€‰æ‹©ç»“æœ
        # :param items: [{'title': 'xxx'}, ...]
        # :return: ç”¨æˆ·é€‰ä¸­çš„ç´¢å¼•åˆ—è¡¨ [0, 2, 5...]ï¼Œå¦‚æœå–æ¶ˆåˆ™è¿”å› None
        self._resume_event.clear()  # é‡ç½®ä¿¡å·ç¯
        self._selection_result = None
        # 1. å‘é€ä¿¡å·ç»™ UIï¼Œè®© UI å¼¹çª—
        self.sig_select_tasks.emit(items)
        # 2. é˜»å¡ç­‰å¾…ï¼Œç›´åˆ° UI è®¾ç½® _resume_event
        # æ¯ç§’é†’æ¥ä¸€æ¬¡æ£€æŸ¥ is_runningï¼Œé˜²æ­¢æ— æ³•åœæ­¢
        while self.is_running:
            if self._resume_event.wait(timeout=1.0):
                break
        if not self.is_running:
            return None
        return self._selection_result
    def resume_from_ui(self, selected_indices):
        """ç”± UI çº¿ç¨‹è°ƒç”¨ï¼Œå”¤é†’çˆ¬è™«"""
        self._selection_result = selected_indices
        self._resume_event.set()  # ç»¿ç¯ï¼Œçˆ¬è™«ç»§ç»­è·‘


# app/spiders/bilibili_spider.py

import os
import re
import time
import json
import requests
import urllib.parse
from playwright.sync_api import sync_playwright
from app.spiders.base_spider import BaseSpider

HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Referer': 'https://www.bilibili.com'
}


class BiliAPI:
    def __init__(self, cookie_path):
        self.sess = requests.Session()
        self.sess.headers.update(HEADERS)
        self.cookie_path = cookie_path
        self.load_cookies()

    def load_cookies(self):
        if os.path.exists(self.cookie_path):
            try:
                with open(self.cookie_path, 'r', encoding='utf-8') as f:
                    cookies = json.load(f)
                    if isinstance(cookies, list):
                        for c in cookies:
                            self.sess.cookies.set(c['name'], c['value'], domain=c['domain'])
                    elif isinstance(cookies, dict):
                        for k, v in cookies.items():
                            self.sess.cookies.set(k, v, domain=".bilibili.com")
            except:
                pass

    def check_login(self):
        try:
            url = "https://api.bilibili.com/x/web-interface/nav"
            resp = self.sess.get(url, timeout=10).json()
            return resp['code'] == 0 and resp['data']['isLogin']
        except:
            return False

    def get_video_info(self, bvid):
        """è·å–è§†é¢‘è¯¦æƒ…"""
        try:
            url = f"https://api.bilibili.com/x/web-interface/view?bvid={bvid}"
            resp = self.sess.get(url, timeout=10).json()
            if resp['code'] != 0: return None
            data = resp['data']

            info = {
                'bvid': data['bvid'],
                'title': data['title'],
                'owner': data['owner']['name'],
                'is_season': False,
                'season_id': None,
                'season_title': "",
                'episodes': []
            }

            # åˆé›†åˆ¤æ–­
            if 'ugc_season' in data and data['ugc_season']:
                info['is_season'] = True
                info['season_id'] = data['ugc_season']['id']
                info['season_title'] = data['ugc_season']['title']
                ep_counter = 1
                for section in data['ugc_season']['sections']:
                    for ep in section['episodes']:
                        info['episodes'].append({
                            'title': ep['title'],
                            'bvid': ep['bvid'],
                            'cid': ep['cid'],
                            'page_num': ep_counter
                        })
                        ep_counter += 1
            else:
                info['season_title'] = data['title']
                for page in data['pages']:
                    info['episodes'].append({
                        'title': page['part'],
                        'bvid': data['bvid'],
                        'cid': page['cid'],
                        'page_num': page['page']
                    })
            return info
        except Exception as e:
            print(f"API Error: {e}")
            return None

    def get_play_url(self, bvid, cid):
        def _request(fnval):
            url = f"https://api.bilibili.com/x/player/playurl?bvid={bvid}&cid={cid}&qn=120&fnval={fnval}&fourk=1"
            return self.sess.get(url, timeout=10).json()

        resp = _request(4048)
        if resp['code'] != 0 or 'data' not in resp or 'dash' not in resp['data']:
            resp = _request(80)

        if resp['code'] == 0 and 'data' in resp and 'dash' in resp['data']:
            dash = resp['data']['dash']
            video_url = dash['video'][0]['baseUrl']
            audio_url = dash['audio'][0]['baseUrl'] if dash.get('audio') else None
            quality_id = dash['video'][0]['id']
            return video_url, audio_url, quality_id
        return None, None, 0


# app/spiders/bilibili_spider.py

import os
import re
import time
import json
import requests
import urllib.parse
import threading
import queue
from concurrent.futures import ThreadPoolExecutor, as_completed
from playwright.sync_api import sync_playwright
from app.spiders.base_spider import BaseSpider

HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
    'Referer': 'https://www.bilibili.com'
}

class BiliAPI:
    def __init__(self, cookie_path):
        self.sess = requests.Session()
        self.sess.headers.update(HEADERS)
        self.cookie_path = cookie_path
        self.load_cookies()

    def load_cookies(self):
        if os.path.exists(self.cookie_path):
            try:
                with open(self.cookie_path, 'r', encoding='utf-8') as f:
                    cookies = json.load(f)
                    if isinstance(cookies, list):
                        for c in cookies:
                            self.sess.cookies.set(c['name'], c['value'], domain=c['domain'])
                    elif isinstance(cookies, dict):
                        for k, v in cookies.items():
                            self.sess.cookies.set(k, v, domain=".bilibili.com")
            except:
                pass

    def check_login(self):
        try:
            url = "https://api.bilibili.com/x/web-interface/nav"
            resp = self.sess.get(url, timeout=10).json()
            return resp['code'] == 0 and resp['data']['isLogin']
        except:
            return False

    def get_video_info(self, bvid):
        """è·å–è§†é¢‘è¯¦æƒ…ï¼Œè¿”å›ç»“æ„åŒ–æ•°æ®"""
        try:
            url = f"https://api.bilibili.com/x/web-interface/view?bvid={bvid}"
            resp = self.sess.get(url, timeout=10).json()
            if resp['code'] != 0: return None
            data = resp['data']

            info = {
                'bvid': data['bvid'],
                'title': data['title'],
                'owner': data['owner']['name'],
                'is_season': False,
                'season_id': None,
                'season_title': "",
                'episodes': []
            }
            # åˆé›†åˆ¤æ–­
            if 'ugc_season' in data and data['ugc_season']:
                info['is_season'] = True
                info['season_id'] = data['ugc_season']['id']
                info['season_title'] = data['ugc_season']['title']
                ep_counter = 1
                for section in data['ugc_season']['sections']:
                    for ep in section['episodes']:
                        info['episodes'].append({
                            'title': ep['title'],
                            'bvid': ep['bvid'],
                            'cid': ep['cid'],
                            'page_num': ep_counter
                        })
                        ep_counter += 1
            else:
                info['season_title'] = data['title']
                for page in data['pages']:
                    info['episodes'].append({
                        'title': page['part'],
                        'bvid': data['bvid'],
                        'cid': page['cid'],
                        'page_num': page['page']
                    })
            return info
        except Exception as e:
            return None

    def get_play_url(self, bvid, cid):
        def _request(fnval):
            url = f"https://api.bilibili.com/x/player/playurl?bvid={bvid}&cid={cid}&qn=120&fnval={fnval}&fourk=1"
            return self.sess.get(url, timeout=10).json()
        resp = _request(4048)
        if resp['code'] != 0 or 'data' not in resp or 'dash' not in resp['data']:
            resp = _request(80)
        if resp['code'] == 0 and 'data' in resp and 'dash' in resp['data']:
            dash = resp['data']['dash']
            video_url = dash['video'][0]['baseUrl']
            audio_url = dash['audio'][0]['baseUrl'] if dash.get('audio') else None
            quality_id = dash['video'][0]['id']
            return video_url, audio_url, quality_id
        return None, None, 0

class BilibiliSpider(BaseSpider):
    def run(self):
        try:
            cookie_file = "bili_auth.json"
            self.api = BiliAPI(cookie_file)
            if not self.api.check_login():
                self.log("ğŸ”’ æœªæ£€æµ‹åˆ°ç™»å½•ï¼Œå¯åŠ¨æµè§ˆå™¨æ‰«ç ...")
                if not self._perform_login_scan(cookie_file):
                    self.log("âš ï¸ ç™»å½•å¤±è´¥ï¼Œä»¥æ¸¸å®¢èº«ä»½çˆ¬å–")
            else:
                self.log("ğŸ‘¤ å·²ç™»å½•ï¼ŒCookie æœ‰æ•ˆ")
            self.log(f"ğŸš€ å¯åŠ¨ Bilibili ä»»åŠ¡ | ç›®æ ‡: {self.keyword}")
            # --- æµæ°´çº¿é˜Ÿåˆ— ---
            self.raw_bv_queue = queue.Queue()
            self.parsed_info_queue = queue.Queue()
            # --- çº¿ç¨‹åŒæ­¥æ ‡å¿— ---
            self.browser_finished = threading.Event()
            self.api_pool_finished = threading.Event()
            # 1. å¯åŠ¨ã€ç”Ÿäº§è€…çº¿ç¨‹ã€‘(æµè§ˆå™¨æ‰«æ)
            browser_thread = threading.Thread(target=self._producer_browser_task)
            browser_thread.start()
            # 2. å¯åŠ¨ã€åŠ å·¥è€…çº¿ç¨‹æ± ã€‘(API è§£æ)
            api_pool_thread = threading.Thread(target=self._worker_api_pool)
            api_pool_thread.start()
            # 3. ã€ä¸»æ§å¾ªç¯ã€‘(è£…é…è€…)
            display_items = []
            cached_data = {}
            seen_season_ids = set()
            seen_bvid_singles = set()
            valid_idx = 0
            self.log("âš¡ æµæ°´çº¿å·²å»ºç«‹: æ‰«æ -> è§£æ -> èšåˆ åŒæ—¶è¿›è¡Œä¸­...")
            while True:
                # é€€å‡ºæ¡ä»¶ï¼šAPI çº¿ç¨‹æ± å®Œæˆä¸”é˜Ÿåˆ—ä¸ºç©º
                if self.api_pool_finished.is_set() and self.parsed_info_queue.empty():
                    break
                if not self.is_running: break
                try:
                    info = self.parsed_info_queue.get(timeout=0.5)
                    # --- å®æ—¶èšåˆé€»è¾‘ ---
                    if info['is_season']:
                        sid = info['season_id']
                        if sid not in seen_season_ids:
                            seen_season_ids.add(sid)
                            count = len(info['episodes'])
                            title_str = f"ã€åˆé›†ã€‘{info['season_title']} (å…± {count} é›†) - {info['owner']}"
                            display_items.append({'title': title_str, 'index': valid_idx})
                            cached_data[valid_idx] = {'type': 'season', 'info': info}
                            valid_idx += 1
                    else:
                        if info['bvid'] not in seen_bvid_singles:
                            seen_bvid_singles.add(info['bvid'])
                            count = len(info['episodes'])
                            if count > 1:
                                title_str = f"ã€å¤šPã€‘{info['title']} (å…± {count} P) - {info['owner']}"
                                item_type = 'multi_p'
                            else:
                                title_str = f"ã€è§†é¢‘ã€‘{info['title']} - {info['owner']}"
                                item_type = 'single'
                            display_items.append({'title': title_str, 'index': valid_idx})
                            cached_data[valid_idx] = {'type': item_type, 'info': info}
                            valid_idx += 1
                    if valid_idx % 5 == 0:
                        self.log(f"   ğŸ“Š å·²èšåˆ {valid_idx} ä¸ªæœ‰æ•ˆèµ„æº...")
                except queue.Empty:
                    continue
            browser_thread.join()
            api_pool_thread.join()
            if not display_items:
                self.log("âŒ æœªæ‰¾åˆ°ä»»ä½•æœ‰æ•ˆè§†é¢‘")
                return
            # ================= 4. ç¬¬ä¸€å±‚äº¤äº’ =================
            self.log(f"ğŸ”” æ‰«æç»“æŸï¼Œå…± {len(display_items)} ä¸ªé¡¹ç›®ï¼Œè¯·é€‰æ‹©...")
            stage1_indices = self.ask_user_selection(display_items)
            if not stage1_indices:
                self.log("âŒ ç”¨æˆ·å–æ¶ˆä¸‹è½½")
                return
            # ================= 5. ç¬¬äºŒå±‚äº¤äº’ & ä¸‹è½½ =================
            final_download_queue = []
            for idx in stage1_indices:
                if not self.is_running: break
                item = cached_data[idx]
                info = item['info']
                episodes = info['episodes']
                item_type = item['type']
                if item_type == 'single':
                    ep = episodes[0]
                    final_download_queue.append({
                        'bvid': ep['bvid'],
                        'cid': ep['cid'],
                        'file_name': self._clean_name(ep['title']) + ".mp4",
                        'folder_name': None,
                        'referer': f"https://www.bilibili.com/video/{ep['bvid']}"
                    })
                    continue
                sub_dialog_items = []
                for i, ep in enumerate(episodes):
                    num_str = str(ep.get('page_num', i + 1)).zfill(2)
                    sub_dialog_items.append({
                        'title': f"[{num_str}] {ep['title']}",
                        'index': i
                    })
                self.log(f"ğŸ”” æ­£åœ¨å±•å¼€: {info.get('season_title') or info['title']}")
                sub_indices = self.ask_user_selection(sub_dialog_items)
                if not sub_indices:
                    continue
                for sub_idx in sub_indices:
                    ep = episodes[sub_idx]
                    folder_name = self._clean_name(info.get('season_title') or info['title'])
                    num_str = str(ep.get('page_num', sub_idx + 1)).zfill(2)
                    safe_title = self._clean_name(ep['title'])
                    file_name = f"P{num_str}_{safe_title}.mp4"
                    final_download_queue.append({
                        'bvid': ep['bvid'],
                        'cid': ep['cid'],
                        'file_name': file_name,
                        'folder_name': folder_name,
                        'referer': f"https://www.bilibili.com/video/{ep['bvid']}"
                    })
            self.log(f"âœ… æœ€ç»ˆç¡®è®¤ {len(final_download_queue)} ä¸ªä»»åŠ¡ï¼Œå¼€å§‹ä¸‹è½½...")
            success_count = 0
            for task in final_download_queue:
                if not self.is_running: break
                self.log(f"ğŸ¬ è§£ææµ: {task['file_name'][:15]}...")
                v_url, a_url, q_id = self.api.get_play_url(task['bvid'], task['cid'])
                if v_url:
                    q_map = {127: "8K", 120: "4K", 116: "1080P60", 80: "1080P", 64: "720P"}
                    q_text = q_map.get(q_id, "é«˜æ¸…")
                    self.log(f"   âœ¨ è·å–æˆåŠŸ [{q_text}]")
                    meta = {
                        "audio_url": a_url,
                        "ua": HEADERS['User-Agent'],
                        "referer": task['referer']
                    }
                    if task['folder_name']:
                        meta["folder_name"] = task['folder_name']
                    self.emit_video(
                        url=v_url,
                        title=task['file_name'],
                        source="bilibili",
                        meta=meta
                    )
                    success_count += 1
                else:
                    self.log(f"   âŒ è·å–æµå¤±è´¥")
                time.sleep(0.5)
            self.log(f"ğŸ‰ å…¨éƒ¨å®Œæˆ: {success_count}/{len(final_download_queue)}")
        finally:
            self.sig_finished.emit()
    # --- çº¿ç¨‹ä»»åŠ¡ï¼šæµè§ˆå™¨ç”Ÿäº§è€… ---
    def _producer_browser_task(self):
        """åªè´Ÿè´£ç¿»é¡µå’Œæå– BVï¼Œæ‰”è¿›é˜Ÿåˆ—"""
        try:
            max_pages = self.config.get('max_pages', 1)
            target_url = self.keyword
            is_search = False
            is_space = False
            # æ¨¡å¼ A: çº¯æ•°å­— -> UPä¸» ID
            if re.match(r'^\d+$', self.keyword):
                self.log(f"ğŸ” [è¯†åˆ«ç»“æœ] UPä¸» UID (çº¯æ•°å­—) -> å‡†å¤‡çˆ¬å–ä¸»é¡µè§†é¢‘")
                target_url = f"https://space.bilibili.com/{self.keyword}/video"
                # UPä¸»æ¨¡å¼å¼ºåˆ¶å…¨é‡
                self._scan_with_browser_queue(target_url, max_pages=9999, is_search=False, is_space=True)
            # æ¨¡å¼ B: çº¯ BV å·
            elif re.match(r'(?i)^BV\w+$', self.keyword):
                self.log("ğŸ”— [è¯†åˆ«ç»“æœ] å•ä¸ªè§†é¢‘ (BVå·)")
                self.raw_bv_queue.put(self.keyword)
            # æ¨¡å¼ C: URL
            elif "http" in self.keyword:
                single_bv = re.search(r'(BV\w+)', self.keyword)
                # æƒ…å†µ C-1: è§†é¢‘è¯¦æƒ…é¡µ
                if "/video/BV" in self.keyword and single_bv and "list" not in self.keyword and "space" not in self.keyword:
                    self.log("ğŸ”— [è¯†åˆ«ç»“æœ] å•ä¸ªè§†é¢‘ (URL)")
                    self.raw_bv_queue.put(single_bv.group(1))
                else:
                    # æƒ…å†µ C-2: ç©ºé—´é¡µ/åˆé›†/åˆ—è¡¨
                    is_space = "space.bilibili.com" in self.keyword
                    if is_space:
                        # ä¸»é¡µé“¾æ¥ä¿®æ­£é€»è¾‘
                        # æ£€æŸ¥æ˜¯å¦åŒ…å« /videoï¼Œå¦‚æœæ²¡æœ‰ï¼Œå°è¯•æå– UID å¹¶æ„é€ 
                        if "/video" not in self.keyword:
                            # æå– UID: space.bilibili.com/1513751793?spm... -> 1513751793
                            uid_match = re.search(r'space\.bilibili\.com/(\d+)', self.keyword)
                            if uid_match:
                                uid = uid_match.group(1)
                                target_url = f"https://space.bilibili.com/{uid}/video"
                                self.log(f"ğŸ”§ [è‡ªåŠ¨ä¿®æ­£] ç©ºé—´ä¸»é¡µ -> è§†é¢‘æŠ•ç¨¿é¡µ: {target_url}")
                            else:
                                self.log(f"ğŸ” [è¯†åˆ«ç»“æœ] ç©ºé—´é¡µ (æœªåŒ¹é…åˆ°UIDï¼Œä¿æŒåŸæ ·)")
                        else:
                            self.log(f"ğŸ” [è¯†åˆ«ç»“æœ] UPä¸»è§†é¢‘æŠ•ç¨¿é¡µ URL")
                        # ç©ºé—´é¡µå¼ºåˆ¶å…¨é‡ï¼Œå¿½ç•¥ max_pages
                        self._scan_with_browser_queue(target_url, max_pages=9999, is_search=False, is_space=True)
                    else:
                        # æœç´¢é¡µ URL (ç›´æ¥ç²˜è´´çš„)
                        is_search_url = "search.bilibili.com" in self.keyword
                        self.log(f"ğŸ” [è¯†åˆ«ç»“æœ] åˆ—è¡¨/æœç´¢é¡µ URL")
                        # å¦‚æœæ˜¯æœç´¢é¡µ URLï¼Œå¿…é¡»å¼€å¯ is_search=True ä»¥ä¾¿æ­£ç¡®ç¿»é¡µ
                        self._scan_with_browser_queue(self.keyword, max_pages, is_search=is_search_url, is_space=False)
            # æ¨¡å¼ D: æœç´¢å…³é”®è¯
            else:
                self.log(f"ğŸ” [è¯†åˆ«ç»“æœ] å…³é”®è¯æœç´¢")
                search_url = f"https://search.bilibili.com/all?keyword={urllib.parse.quote(self.keyword)}"
                self._scan_with_browser_queue(search_url, max_pages, is_search=True, is_space=False)
        except Exception as e:
            self.log(f"âŒ æµè§ˆå™¨çº¿ç¨‹å¼‚å¸¸: {e}")
        finally:
            self.browser_finished.set()
            # --- çº¿ç¨‹ä»»åŠ¡ï¼šAPI åŠ å·¥è€… ---

    def _worker_api_pool(self):
        def process_one(bvid):
            if not self.is_running: return None
            return self.api.get_video_info(bvid)
        with ThreadPoolExecutor(max_workers=8) as executor:
            while True:
                if self.browser_finished.is_set() and self.raw_bv_queue.empty():
                    break
                if not self.is_running: break
                try:
                    bvid = self.raw_bv_queue.get(timeout=0.5)
                    future = executor.submit(process_one, bvid)
                    def callback(f):
                        try:
                            res = f.result()
                            if res: self.parsed_info_queue.put(res)
                        except:
                            pass
                    future.add_done_callback(callback)
                except queue.Empty:
                    continue
            pass
        self.api_pool_finished.set()

    # --- æµè§ˆå™¨æ‰«æé€»è¾‘ ---
    def _scan_with_browser_queue(self, url, max_pages=1, is_search=False, is_space=False):
        bv_set = set()
        try:
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=False)
                page = browser.new_page()
                current_url = url
                page.goto(url, timeout=60000)
                page.wait_for_load_state("domcontentloaded")
                # UP ä¸»æ‹¦æˆª (ä»…é’ˆå¯¹å…³é”®è¯æœç´¢æ¨¡å¼)
                if is_search and "search.bilibili.com" in url:
                    try:
                        up_link = page.locator(".user-list .b-user-video-card .user-name").first
                        if up_link.is_visible():
                            up_name = up_link.inner_text()
                            up_href = up_link.get_attribute("href")
                            if up_href:
                                uid_match = re.search(r'space\.bilibili\.com/(\d+)', up_href)
                                if uid_match:
                                    uid = uid_match.group(1)
                                    self.log(f"âœ¨ æ£€æµ‹åˆ° UP ä¸»: {up_name}...")
                                    target_video_url = f"https://space.bilibili.com/{uid}/video"
                                    page.goto(target_video_url)
                                    page.wait_for_load_state("domcontentloaded")
                                    current_url = page.url
                                    is_search = False
                                    is_space = True
                                    max_pages = 9999
                    except Exception:
                        pass
                page_count = 0
                while self.is_running and page_count < max_pages:
                    page_count += 1
                    for _ in range(3):
                        page.evaluate("window.scrollBy(0, 1000)")
                        time.sleep(0.3)
                    hrefs = page.evaluate('''() => {
                        const anchors = document.querySelectorAll('a[href*="/video/BV"]');
                        return Array.from(anchors).map(a => a.href);
                    }''')
                    new_count = 0
                    for href in hrefs:
                        match = re.search(r'video/(BV\w+)', href)
                        if match:
                            bvid = match.group(1)
                            if bvid not in bv_set:
                                bv_set.add(bvid)
                                self.raw_bv_queue.put(bvid)
                                new_count += 1
                    self.log(f"   ğŸ“„ ç¬¬ {page_count} é¡µ: å‘ç° {new_count} ä¸ª")
                    if new_count == 0:
                        page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
                        time.sleep(1)
                        if new_count == 0: break
                    if page_count < max_pages:
                        next_url = None
                        if is_search:
                            base_search = re.sub(r'&page=\d+', '', current_url)
                            base_search = re.sub(r'&o=\d+', '', base_search)
                            next_page = page_count + 1
                            offset = (next_page - 1) * 30
                            next_url = f"{base_search}&page={next_page}&o={offset}"
                        elif is_space:
                            try:
                                next_btn = page.locator("button:has-text('ä¸‹ä¸€é¡µ')").first
                                if next_btn.is_visible() and next_btn.is_enabled():
                                    next_btn.click()
                                    page.wait_for_timeout(2000)
                                    continue
                                else:
                                    break
                            except:
                                break
                        else:
                            try:
                                next_btn = page.locator("button.next-page, li.next").first
                                if next_btn.is_visible():
                                    next_btn.click()
                                    page.wait_for_timeout(2000)
                                    continue
                                else:
                                    break
                            except:
                                break
                        if next_url:
                            page.goto(next_url)
                            page.wait_for_timeout(2000)
                        else:
                            break
                browser.close()
        except Exception as e:
            self.log(f"âš ï¸ æ‰«æå¼‚å¸¸: {e}")

    def _clean_name(self, name):
        return re.sub(r'[\\/:*?"<>|]', '_', str(name)).strip()

    def _perform_login_scan(self, save_path):
        try:
            with sync_playwright() as p:
                browser = p.chromium.launch(headless=False)
                context = browser.new_context()
                page = context.new_page()
                page.goto("https://passport.bilibili.com/login", timeout=60000)
                self.log("â³ è¯·åœ¨å¼¹å‡ºçš„çª—å£ä¸­æ‰«ç ç™»å½•...")
                for _ in range(60):
                    if not self.is_running:
                        browser.close()
                        return False
                    cookies = context.cookies()
                    if any(c['name'] == 'SESSDATA' for c in cookies):
                        with open(save_path, 'w') as f:
                            json.dump(cookies, f, indent=4, ensure_ascii=False)
                        self.log("âœ… æ‰«ç æˆåŠŸï¼ŒCookie å·²ä¿å­˜")
                        browser.close()
                        self.api.load_cookies()
                        return True
                    time.sleep(1)
                browser.close()
                return False
        except Exception:
            return False

# app/spiders/kuaishou_spider.py

import os
import time
import random
import json
import re
import urllib.parse
import base64
import threading
from playwright.sync_api import sync_playwright
from app.spiders.base_spider import BaseSpider

class KuaishouSpider(BaseSpider):

    def run(self):
        auth_file = "ks_auth.json"
        # çº¿ç¨‹åŒæ­¥é”
        self._lock = threading.Lock()
        # ä»£ç†é…ç½®
        proxy_cfg = None
        if self.config.get('proxy'):
            proxy_cfg = {"server": self.config['proxy']}
            self.log(f"ğŸŒ ä½¿ç”¨ä»£ç†: {self.config['proxy']}")
        self.log(f"ğŸš€ å¯åŠ¨å¿«æ‰‹ä»»åŠ¡ | ç›®æ ‡: {self.keyword}")
        try:
            with sync_playwright() as p:
                # 1. å¯åŠ¨æµè§ˆå™¨
                browser = p.chromium.launch(
                    headless=False,
                    proxy=proxy_cfg,
                    args=['--disable-blink-features=AutomationControlled']
                )
                context = browser.new_context(
                    user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                    viewport={"width": 1280, "height": 800}
                )
                if os.path.exists(auth_file):
                    try:
                        with open(auth_file, 'r', encoding='utf-8') as f:
                            cookies = json.load(f)
                        if isinstance(cookies, dict) and 'cookies' in cookies:
                            # å…¼å®¹ playwright storage_state æ ¼å¼
                            context.add_cookies(cookies['cookies'])
                        elif isinstance(cookies, list):
                            context.add_cookies(cookies)
                        self.log("ğŸ“‚ åŠ è½½æœ¬åœ° Cookie æˆåŠŸ")
                    except:
                        pass
                page = context.new_page()
                # ================= é˜¶æ®µä¸€ï¼šç™»å½•ä¸å¯¼èˆª =================
                self.log("ğŸ”— è®¿é—®å¿«æ‰‹é¦–é¡µ...")
                page.goto("https://www.kuaishou.com/", timeout=60000)
                try:
                    page.wait_for_selector(".header-user-avatar, .user-avatar", timeout=5000)
                    self.log("âœ… æ£€æµ‹åˆ°ç™»å½•çŠ¶æ€")
                except:
                    self.log("ğŸ”‘ æœªç™»å½•ï¼Œå°è¯•è‡ªåŠ¨è§¦å‘ç™»å½•å¼¹çª—...")
                    try:
                        page.locator(".login-btn, text=ç™»å½•").first.click()
                    except:
                        pass

                    for _ in range(120):
                        if not self.is_running: return
                        cookies = context.cookies()
                        if any(c['name'] == 'userId' for c in cookies):
                            # ä¿å­˜ä¸ºæ˜“è¯»æ ¼å¼
                            storage = context.storage_state()
                            with open(auth_file, 'w', encoding='utf-8') as f:
                                json.dump(storage, f, indent=4, ensure_ascii=False)
                            self.log("âœ… ç™»å½•æˆåŠŸï¼ŒCookie å·²ä¿å­˜")
                            break
                        page.wait_for_timeout(1000)
                if not self.is_running: return
                if "kuaishou.com" in self.keyword:
                    page.goto(self.keyword)
                else:
                    search_url = f"https://www.kuaishou.com/search/author?source=NewReco&searchKey={self.keyword}"
                    page.goto(search_url)
                    page.wait_for_timeout(2000)
                    try:
                        user_card = page.locator(".card-item .detail-user-name").first
                        if user_card.is_visible():
                            name = user_card.inner_text()
                            self.log(f"ğŸ‘‰ è¿›å…¥ä¸»æ’­ä¸»é¡µ: {name}")
                            user_card.click()
                            page.wait_for_timeout(3000)
                            if len(context.pages) > 1:
                                page = context.pages[-1]
                                page.bring_to_front()
                        else:
                            self.log("âŒ æœªæ‰¾åˆ°ä¸»æ’­")
                            return
                    except:
                        return
                try:
                    page.wait_for_selector(".photo-card, .video-card", timeout=15000)
                except:
                    self.log("âŒ æ— æ³•åŠ è½½è§†é¢‘åˆ—è¡¨")
                    return
                # ================= é˜¶æ®µäºŒï¼šæ»šåŠ¨æ‰«æ =================
                self.log("\nğŸ“œ å¼€å§‹æ»šåŠ¨åŠ è½½åˆ—è¡¨... (ç‚¹å‡»ã€åœæ­¢ã€‘ç”Ÿæˆæ¸…å•)")
                scroll_count = 0
                last_card_count = 0
                no_new_content_count = 0
                while self.is_running:
                    scroll_count += 1
                    # 1. æ¨¡æ‹Ÿäººç±»é¼ æ ‡ç§»åŠ¨ (é˜²é£æ§)
                    try:
                        vp = page.viewport_size
                        if vp:
                            page.mouse.move(vp['width'] / 2, vp['height'] / 2)
                    except:
                        pass
                    # 2. æ··åˆæ»šåŠ¨ç­–ç•¥
                    page.evaluate("window.scrollBy(0, 800)")
                    page.wait_for_timeout(500)
                    page.mouse.wheel(0, 500)  # æ¨¡æ‹Ÿæ»šè½®ï¼Œè¿™å¾ˆé‡è¦
                    page.wait_for_timeout(1000)
                    # 3. æ£€æŸ¥æ•°é‡
                    cards = page.locator(".photo-card, .video-card")
                    current_card_count = cards.count()
                    # 4. æ£€æŸ¥"æ²¡æœ‰æ›´å¤š"
                    no_more = False
                    try:
                        no_more_el = page.locator("text='æ²¡æœ‰æ›´å¤šäº†'")
                        if no_more_el.count() > 0 and no_more_el.first.is_visible(): no_more = True
                    except:
                        pass
                    if no_more:
                        self.log("âœ… å·²åŠ è½½å…¨éƒ¨è§†é¢‘")
                        break
                    # 5. æ­»é”æ£€æµ‹ä¸æ¿€æ´»
                    if current_card_count == last_card_count:
                        no_new_content_count += 1
                        if no_new_content_count >= 5:
                            self.log("ğŸ”„ ä¼¼ä¹å¡ä½äº†ï¼Œå°è¯•å›æ»šåˆ·æ–°...")
                            # å›æ»šç­–ç•¥ï¼šå¾€ä¸Šæ»‘ä¸€ç‚¹ï¼Œå†ç‹ æ»‘åˆ°åº•
                            page.evaluate("window.scrollBy(0, -1000)")
                            page.wait_for_timeout(1000)
                            page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
                            no_new_content_count = 0
                    else:
                        no_new_content_count = 0
                        last_card_count = current_card_count
                    if scroll_count % 3 == 0:
                        self.log(f"â¬‡ï¸ åŠ è½½ä¸­... (å·²æ‰«æ {current_card_count} ä¸ª)")
                if not self.is_running:
                    if last_card_count > 0:
                        self.log("â¸ï¸ æ‰«æè¢«ä¸­æ–­ï¼Œå‡†å¤‡ç”Ÿæˆæ¸…å•...")
                        self.is_running = True  # å¤æ´»çº¿ç¨‹
                    else:
                        self.log("ğŸ›‘ ä»»åŠ¡å·²ç»ˆæ­¢")
                        browser.close()
                        return
                    # ================= é˜¶æ®µä¸‰ï¼šæå–ç‰¹å¾ & å¼¹çª— =================
                self.log("ğŸ§  è§£æè§†é¢‘ä¿¡æ¯...")
                # 1. æå–æ ‡é¢˜
                video_titles = page.evaluate("""() => {
                    const cards = document.querySelectorAll('.photo-card, .video-card');
                    return Array.from(cards).map(c => {
                        const titleEl = c.querySelector('[class*="caption"]');
                        return titleEl ? titleEl.innerText : '';
                    });
                }""")
                # 2. æå–å°é¢å›¾ URL
                video_imgs = page.evaluate("""() => {
                    const cards = document.querySelectorAll('.photo-card, .video-card');
                    return Array.from(cards).map(c => {
                        const imgEl = c.querySelector('img.cover-img');
                        return imgEl ? imgEl.src : '';
                    });
                }""")
                items_for_dialog = []
                target_fingerprints_map = {}
                for idx, raw_title in enumerate(video_titles):
                    clean_title = raw_title.replace('\n', ' ').strip()
                    if not clean_title: clean_title = f"æœªå‘½åè§†é¢‘_{idx + 1}"
                    items_for_dialog.append({'title': clean_title, 'index': idx})
                    if idx < len(video_imgs):
                        img_url = video_imgs[idx]
                        ids = self._extract_all_possible_ids(img_url)
                        target_fingerprints_map[idx] = ids
                if not items_for_dialog:
                    self.log("âŒ æœªæ‰«æåˆ°æœ‰æ•ˆè§†é¢‘")
                    return
                self.log(f"ğŸ”” æ‰«æå®Œæˆï¼Œå…± {len(items_for_dialog)} ä¸ªï¼Œè¯·é€‰æ‹©ä¸‹è½½...")
                selected_indices = self.ask_user_selection(items_for_dialog)
                if not selected_indices:
                    self.log("âŒ ç”¨æˆ·å–æ¶ˆäº†ä¸‹è½½ä»»åŠ¡")
                    browser.close()
                    return
                self.is_running = True
                target_indices_set = set(selected_indices)
                submitted_indices = set()
                encrypted_queue = []
                max_target_idx = max(selected_indices)
                self.log(f"âœ… é€‰ä¸­ {len(target_indices_set)} ä¸ªä»»åŠ¡ï¼Œæµæ°´çº¿å¯åŠ¨...")
                # ================= é˜¶æ®µå››ï¼šå®æ—¶æµæ°´çº¿ =================
                current_focus_index = 0
                # 1. æ¶ˆè´¹è€…ï¼šç½‘ç»œç›‘å¬å™¨
                def handle_response(response):
                    ctype = response.headers.get("content-type", "")
                    if response.request.resource_type == "media" or \
                            "video/mp4" in ctype or \
                            "mpegurl" in ctype.lower() or \
                            ".m3u8" in response.url:
                        try:
                            if ".mp4" in response.url:
                                try:
                                    if int(response.headers.get("content-length", 0)) < 5000: return
                                except:
                                    pass
                            url = response.url
                            vid_ids = self._extract_all_possible_ids(url)
                            matched_idx = -1
                            with self._lock:
                                # A. ç²¾ç¡® ID åŒ¹é…
                                if vid_ids:
                                    for idx in target_indices_set:
                                        if idx in submitted_indices: continue
                                        cover_ids = target_fingerprints_map.get(idx, set())
                                        if not cover_ids.isdisjoint(vid_ids):
                                            matched_idx = idx
                                            break
                                # B. æ—¶åºç„¦ç‚¹åŒ¹é… (å…œåº•)
                                if matched_idx == -1 and "pkey" in url:
                                    if current_focus_index in target_indices_set and current_focus_index not in submitted_indices:
                                        matched_idx = current_focus_index
                                        self.log(
                                            f"   ğŸ”’ [åŠ å¯†æµ] åŒ¹é…ç„¦ç‚¹: {items_for_dialog[matched_idx]['title'][:10]}...")
                                # æäº¤ä¸‹è½½
                                if matched_idx != -1:
                                    submitted_indices.add(matched_idx)
                                    title = items_for_dialog[matched_idx]['title']
                                    source_type = "kuaishou"
                                    if ".m3u8" in url: source_type = "missav"
                                    self.log(f"   âœ¨ [æ•è·] {title[:15]}... -> åŠ å…¥ä¸‹è½½é˜Ÿåˆ—")
                                    self.emit_video(
                                        url=url,
                                        title=title,
                                        source=source_type,
                                        meta={"referer": page.url}
                                    )
                        except Exception as e:
                            pass
                page.on("response", handle_response)
                # 2. ç”Ÿäº§è€…ï¼šåˆ·å±
                page.evaluate("window.scrollTo(0, 0)")
                page.wait_for_timeout(1000)
                cards = page.locator(".photo-card, .video-card")
                try:
                    first_card = cards.first
                    if not first_card.is_visible(): first_card.scroll_into_view_if_needed()
                    first_card.click()
                    page.wait_for_timeout(3000)
                    try:
                        page.mouse.click(200, 200)
                    except:
                        pass
                except:
                    self.log("âŒ æ— æ³•è¿›å…¥è¯¦æƒ…é¡µ")
                    return
                current_focus_index = 0
                total_scrolls = len(items_for_dialog)
                self.log(f"ğŸ”„ ç”Ÿäº§è€…å·¥ä½œå¼€å§‹ (0 - {total_scrolls})...")
                while current_focus_index < total_scrolls and self.is_running:
                    # æå‰ç»“æŸæ£€æŸ¥
                    with self._lock:
                        if len(submitted_indices) >= len(target_indices_set):
                            self.log("ğŸ‰ æ‰€æœ‰ä»»åŠ¡å·²å®æ—¶æ•è·ï¼Œæå‰ç»“æŸï¼")
                            break
                    if (current_focus_index + 1) % 5 == 0:
                        self.log(f"ğŸ”„ åˆ·å±è¿›åº¦: {current_focus_index + 1}/{total_scrolls}")
                    page.keyboard.press("ArrowDown")
                    with self._lock:
                        current_focus_index += 1
                    is_target = current_focus_index in target_indices_set
                    if is_target:
                        wait_ms = random.randint(1500, 2500)
                    else:
                        wait_ms = random.randint(600, 1000)
                    page.wait_for_timeout(wait_ms)
                    try:
                        if page.locator(".close-icon").is_visible():
                            page.locator(".close-icon").click()
                    except:
                        pass
                # ç»“æŸæ±‡æŠ¥
                self.log(f"\nğŸ“Š æµç¨‹ç»“æŸã€‚")
                not_found = target_indices_set - submitted_indices
                if not_found:
                    self.log(f"âš ï¸ {len(not_found)} ä¸ªè§†é¢‘æœªæ•è·:")
                    for idx in sorted(list(not_found)):
                        self.log(f"   - [{idx + 1}] {items_for_dialog[idx]['title'][:20]}...")
                else:
                    self.log("âœ… å…¨éƒ¨ä»»åŠ¡å®Œæˆï¼")
                browser.close()
        except Exception as e:
            self.log(f"ğŸ’¥ çˆ¬è™«é”™è¯¯: {e}")
        self.sig_finished.emit()
    def _extract_all_possible_ids(self, url):
        # ä¿æŒä¹‹å‰çš„å¤šæ¨¡æ€ç®—æ³•ä¸å˜ï¼Œå› ä¸ºå®ƒå¾ˆå¼º
        if not url: return set()
        ids = set()
        try:
            parsed = urllib.parse.urlparse(url)
            qs = urllib.parse.parse_qs(urllib.parse.unquote(parsed.query))
            path = parsed.path
            filename = path.split('/')[-1]
            # 1. clientCacheKey
            if 'clientCacheKey' in qs:
                key = qs['clientCacheKey'][0]
                key_no_ext = key.rsplit('.', 1)[0]
                match = re.match(r'^([a-zA-Z0-9]+)', key_no_ext)
                if match: ids.add(match.group(1))
            # 2. x-ks-ptid
            if 'x-ks-ptid' in qs:
                ids.add(qs['x-ks-ptid'][0])
            # 3. Base64
            b64_match = re.search(r'(BMj[a-zA-Z0-9+/]+)', path)
            if not b64_match: b64_match = re.search(r'(BMj[a-zA-Z0-9+/]+)', urllib.parse.unquote(parsed.query))
            if b64_match:
                b64_str = b64_match.group(1)
                try:
                    missing_padding = len(b64_str) % 4
                    if missing_padding: b64_str += '=' * (4 - missing_padding)
                    decoded_bytes = base64.b64decode(b64_str)
                    decoded_str = decoded_bytes.decode('utf-8', errors='ignore')
                    parts = decoded_str.split('_')
                    if len(parts) >= 3 and parts[2].isdigit() and len(parts[2]) >= 10:
                        ids.add(parts[2])
                    nums = re.findall(r'\d{10,}', decoded_str)
                    ids.update(nums)
                except:
                    pass
            # 4. è·¯å¾„å›é€€
            name_no_ext = filename.rsplit('.', 1)[0]
            ids.add(name_no_ext)
            if '_b_B' in name_no_ext: ids.add(name_no_ext.split('_b_B')[0])
        except:
            pass
        return ids


# app/spiders/missav_spider.py

import re
import time
import urllib.parse
from collections import defaultdict
from playwright.sync_api import sync_playwright
from app.spiders.base_spider import BaseSpider

class MissAVSpider(BaseSpider):

    def run(self):
        try:
            # é…ç½®è§£æ (ä¿æŒä¸å˜)
            proxy_server = None
            if self.config.get('proxy'):
                proxy_server = self.config['proxy']
                self.log(f"ğŸŒ ä½¿ç”¨ä»£ç†: {proxy_server}")
            enable_individual = self.config.get('individual_only', False)
            priority_text = self.config.get('priority', "ä¸­æ–‡å­—å¹•ä¼˜å…ˆ")
            priority_map = {
                "ä¸­æ–‡å­—å¹•ä¼˜å…ˆ": ["ä¸­æ–‡å­—å¹•", "æ— ç æµå‡º", "è‹±æ–‡å­—å¹•", "æ™®é€šç‰ˆ"],
                "æ— ç æµå‡ºä¼˜å…ˆ": ["æ— ç æµå‡º", "ä¸­æ–‡å­—å¹•", "è‹±æ–‡å­—å¹•", "æ™®é€šç‰ˆ"]
            }
            self.priority_list = priority_map.get(priority_text, priority_map["ä¸­æ–‡å­—å¹•ä¼˜å…ˆ"])
            self.log(f"âš™ï¸ åå¥½è®¾ç½®: å•ä½“={enable_individual}, ä¼˜å…ˆçº§={self.priority_list}")
            my_ua = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            # è·¯ç”±è§£æ (ä¿æŒä¸å˜)
            target_url = ""
            is_single_video_mode = False
            is_search_mode = False
            raw_input = self.keyword.strip()
            if "http" in raw_input:
                parsed = urllib.parse.urlparse(raw_input)
                path_parts = parsed.path.strip('/').split('/')
                keywords_list = ['search', 'actresses', 'tags', 'series', 'makers', 'directors', 'labels']
                if not any(k in parsed.path for k in keywords_list) and re.search(r'\w+-\d+', path_parts[-1]):
                    is_single_video_mode = True
                    target_url = raw_input
                    self.log("ğŸ”— è¯†åˆ«ä¸ºå•ä½“è§†é¢‘é“¾æ¥")
                else:
                    target_url = raw_input
                    self.log("ğŸ”— è¯†åˆ«ä¸ºåˆ—è¡¨/åˆ†ç±»é“¾æ¥")
            else:
                is_search_mode = True
                encoded_kw = urllib.parse.quote(raw_input)
                target_url = f"https://missav.ai/cn/search/{encoded_kw}"
                self.log(f"ğŸ” æ„é€ æœç´¢é“¾æ¥: {target_url}")
            if not is_single_video_mode:
                target_url = self._inject_url_params(target_url, enable_individual)
                self.log(f"ğŸ”§ ä¿®æ­£å URL: {target_url}")
            if not self.is_running: return
            # å¯åŠ¨æµè§ˆå™¨
            with sync_playwright() as p:
                browser = p.chromium.launch(
                    headless=False,
                    proxy={"server": proxy_server} if proxy_server else None,
                    args=['--disable-blink-features=AutomationControlled']
                )
                context = browser.new_context(user_agent=my_ua)
                page = context.new_page()
                self.log("ğŸš€ æ­£åœ¨è®¿é—®é¡µé¢...")
                page.goto(target_url, timeout=60000)
                if "Just a moment" in page.title():
                    self.log("ğŸ›¡ï¸ æ£€æµ‹åˆ° Cloudflareï¼Œç­‰å¾…é€šè¿‡...")
                    page.wait_for_timeout(5000)
                    page.wait_for_load_state("domcontentloaded")
                # å¤´åƒè·³è½¬
                if is_search_mode and self.is_running:
                    try:
                        time.sleep(2)
                        links = page.query_selector_all('a[href*="/actresses/"]')
                        valid_actress_link = None
                        for link in links:
                            href = link.get_attribute("href")
                            if href and "ranking" not in href and "search" not in href:
                                if link.is_visible():
                                    valid_actress_link = link
                                    break
                        if valid_actress_link:
                            href = valid_actress_link.get_attribute("href")
                            self.log(f"âœ¨ å‘ç°æ¼”å‘˜ä¸»é¡µï¼Œè‡ªåŠ¨è·³è½¬: {href}")
                            valid_actress_link.click()
                            page.wait_for_load_state('domcontentloaded')
                            current_url = page.url
                            new_url = self._inject_url_params(current_url, enable_individual)
                            if new_url != current_url:
                                page.goto(new_url)
                    except:
                        pass
                if not self.is_running:
                    browser.close()
                    return
                # æ•°æ®é‡‡é›†
                final_tasks = []
                if is_single_video_mode:
                    title = page.title().replace('| MissAV', '').strip()
                    final_tasks.append({'title': title, 'url': page.url})
                else:
                    scraped_data = {}
                    verified_chinese = set()
                    base_url = page.url
                    # --- Pass 1: ä¸»éå† ---
                    self.log("ğŸ“œ å¼€å§‹ç¬¬ä¸€éæ‰«æ (è·å–æ‰€æœ‰è§†é¢‘)...")
                    self._scan_pages(page, scraped_data, is_chinese_pass=False)

                    if not self.is_running:
                        self.log("â¸ï¸ æ‰«æè¢«ä¸­æ–­ï¼Œè·³è¿‡ä¸­æ–‡æ ¡éªŒï¼Œå‡†å¤‡ç”Ÿæˆæ¸…å•...")
                    if not scraped_data:
                        self.log("âŒ æœªæ‰¾åˆ°ä»»ä½•è§†é¢‘")
                        browser.close()
                        return
                    # --- Pass 2: ä¸­æ–‡æ ¡éªŒ (ä»…å½“æœªåœæ­¢æ—¶æ‰§è¡Œ) ---
                    # åªæœ‰å½“è¿˜åœ¨è¿è¡Œæ—¶ï¼Œæ‰å»æ‰«ç¬¬äºŒé
                    if self.is_running:
                        self.log("ğŸ‡¨ğŸ‡³ å¼€å§‹ç¬¬äºŒéæ‰«æ (æ ¡éªŒä¸­æ–‡å­—å¹•)...")
                        chinese_url = self._add_chinese_filter(base_url)

                        if chinese_url != base_url:
                            self.log(f"   è·³è½¬æ ¡éªŒ: {chinese_url}")
                            try:
                                chinese_url_no_page = re.sub(r'[?&]page=\d+', '', chinese_url)
                                page.goto(chinese_url_no_page, timeout=60000)

                                chinese_data = {}
                                self._scan_pages(page, chinese_data, is_chinese_pass=True)
                                verified_chinese = set(chinese_data.keys())
                                scraped_data.update(chinese_data)
                            except Exception as e:
                                self.log(f"   âš ï¸ ä¸­æ–‡æ ¡éªŒå¼‚å¸¸: {e}")

                    if not self.is_running and scraped_data:
                        self.is_running = True
                    # --- æ™ºèƒ½åˆ†ç»„æ‰“åˆ† ---
                    self.log(f"ğŸ§  æ™ºèƒ½ç­›é€‰ä¸­ (å…± {len(scraped_data)} ä¸ªå€™é€‰)...")
                    grouped = defaultdict(list)
                    code_pattern = re.compile(r'/cn/.*?([a-zA-Z]+-\d+)')

                    for url, title in scraped_data.items():
                        code = None
                        match = code_pattern.search(url)
                        if match: code = match.group(1).upper()

                        if code:
                            grouped[code].append((url, title))
                        else:
                            grouped[url].append((url, title))

                    for code, items in grouped.items():
                        sorted_items = sorted(
                            items,
                            key=lambda x: self._calculate_score(x[0], x[1], verified_chinese),
                            reverse=True
                        )
                        best_url, best_title = sorted_items[0]
                        final_title = self._generate_display_title(best_url, best_title, verified_chinese)
                        final_tasks.append({'title': final_title, 'url': best_url})

                # ================= 4. ç”¨æˆ·äº¤äº’ =================
                if not final_tasks:
                    self.log("âŒ ç­›é€‰åæ— æœ‰æ•ˆç»“æœ")
                    browser.close()
                    return
                self.log(f"ğŸ”” æ‰«æå®Œæˆï¼Œå…± {len(final_tasks)} ä¸ªæœ€ä½³ç‰ˆæœ¬")

                # ç¡®ä¿å¤æ´»ï¼Œå¦åˆ™å¼¹çª—é€»è¾‘ä¼šç«‹å³é€€å‡º
                self.is_running = True
                # å¼¹çª—é€‰æ‹©
                selected_indices = self.ask_user_selection(final_tasks)
                # å¦‚æœæ­¤æ—¶è¿”å› Noneï¼Œè¯´æ˜ç”¨æˆ·åœ¨å¼¹çª—é‡Œç‚¹äº†â€œå–æ¶ˆâ€
                if not selected_indices:
                    self.log("âŒ ç”¨æˆ·å–æ¶ˆä¸‹è½½")
                    browser.close()
                    return
                self.log(f"âœ… é€‰ä¸­ {len(selected_indices)} ä¸ªï¼Œå¼€å§‹å—…æ¢ m3u8...")

                # ================= 5. è¯¦æƒ…é¡µå—…æ¢ (playlist.m3u8) =================
                success_count = 0
                for i, idx in enumerate(selected_indices):
                    if not self.is_running: break
                    task = final_tasks[idx]
                    target_page_url = task['url']
                    title = task['title']
                    self.log(f"ğŸ•µï¸ [{i + 1}/{len(selected_indices)}] å—…æ¢: {title[:15]}...")
                    m3u8_url = None
                    def handle_request(req):
                        nonlocal m3u8_url
                        if "playlist.m3u8" in req.url:
                            m3u8_url = req.url
                    def on_popup(popup):
                        if popup != page:
                            try:
                                popup.close()
                            except:
                                pass
                    context.on("page", on_popup)
                    page.on("request", handle_request)
                    try:
                        page.goto(target_page_url, timeout=60000)
                        if "Just a moment" in page.title():
                            time.sleep(10)
                        try:
                            page.wait_for_selector(".plyr", timeout=5000)
                            page.mouse.click(400, 300)
                            time.sleep(2)
                            if not m3u8_url: page.mouse.click(400, 300)
                        except:
                            pass
                        for _ in range(15):
                            if m3u8_url or not self.is_running: break
                            time.sleep(1)
                        if not self.is_running: break
                        if m3u8_url:
                            self.log("   âœ¨ å—…æ¢æˆåŠŸ")
                            self.emit_video(
                                url=m3u8_url,
                                title=title,
                                source="missav",
                                meta={
                                    "referer": target_page_url,
                                    "ua": my_ua,
                                    "proxy": proxy_server
                                }
                            )
                            success_count += 1
                        else:
                            self.log("   âš ï¸ å—…æ¢è¶…æ—¶ (æœªæ‰¾åˆ° playlist.m3u8)")
                    except Exception as e:
                        self.log(f"   âŒ é¡µé¢åŠ è½½é”™è¯¯: {e}")
                    page.remove_listener("request", handle_request)
                    context.remove_listener("page", on_popup)
                    time.sleep(1)
                if self.is_running:
                    self.log(f"ğŸ‰ ä»»åŠ¡ç»“æŸï¼ŒæˆåŠŸæäº¤: {success_count}")
                else:
                    self.log("ğŸ›‘ ä»»åŠ¡å¼ºåˆ¶ä¸­æ­¢")
                browser.close()
        except Exception as e:
            self.log(f"ğŸ’¥ çˆ¬è™«é”™è¯¯: {e}")
        finally:
            self.sig_finished.emit()

    def _inject_url_params(self, url, individual_only):
        parsed = urllib.parse.urlparse(url)
        qs = urllib.parse.parse_qs(parsed.query)
        if individual_only:
            filters = qs.get('filters', [''])[0]
            parts = filters.split(',') if filters else []
            if 'individual' not in parts:
                parts.append('individual')
                new_filters = ",".join([p for p in parts if p])
                qs['filters'] = [new_filters]
        new_query = urllib.parse.urlencode(qs, doseq=True)
        return urllib.parse.urlunparse(parsed._replace(query=new_query))

    def _add_chinese_filter(self, url):
        parsed = urllib.parse.urlparse(url)
        qs = urllib.parse.parse_qs(parsed.query)
        filters = qs.get('filters', [''])[0]
        parts = filters.split(',') if filters else []
        if 'chinese-subtitle' not in parts:
            parts.append('chinese-subtitle')
            qs['filters'] = [",".join([p for p in parts if p])]
        new_query = urllib.parse.urlencode(qs, doseq=True)
        return urllib.parse.urlunparse(parsed._replace(query=new_query))

    def _scan_pages(self, page, data_dict, is_chinese_pass=False):
        current_page = 1
        max_pages = 100
        base_url = page.url
        while self.is_running and current_page <= max_pages:
            self.log(f"   ğŸ“„ æ‰«æç¬¬ {current_page} é¡µ...")
            try:
                page.wait_for_selector("div.grid", timeout=10000)
                items = page.evaluate('''() => {
                    return Array.from(document.querySelectorAll('div.grid a')).map(a => {
                        const img = a.querySelector('img');
                        const title = img ? img.getAttribute('alt') : a.textContent.trim();
                        return {
                            url: a.href,
                            title: title || ""
                        };
                    });
                }''')

                code_pattern = re.compile(r'/cn/.*[a-zA-Z]+-\d+')
                new_count = 0
                for item in items:
                    url = item['url']
                    title = item['title']
                    if "/cn/" in url and code_pattern.search(url):
                        if not any(x in url for x in ['contact', 'dmca']):
                            if url not in data_dict:
                                data_dict[url] = title
                                new_count += 1

                if not page.query_selector("a[rel='next']"):
                    break
                current_page += 1
                if "page=" in base_url:
                    next_url = re.sub(r'page=\d+', f'page={current_page}', base_url)
                else:
                    sep = "&" if "?" in base_url else "?"
                    next_url = f"{base_url}{sep}page={current_page}"
                try:
                    page.goto(next_url, timeout=60000)
                except:
                    break
            except Exception as e:
                self.log(f"   âš ï¸ é¡µé¢æ‰«æå¼‚å¸¸: {e}")
                break

    def _calculate_score(self, url, title, verified_chinese):
        url_lower = url.lower()
        title_lower = title.lower()
        is_uncensored = "uncensored" in url_lower or "leak" in url_lower or "æ— ç " in title_lower
        is_english = "english" in url_lower or "è‹±æ–‡å­—å¹•" in title_lower
        is_chinese = (url in verified_chinese) or ("chinese" in url_lower) or ("ä¸­æ–‡å­—å¹•" in title_lower)
        if is_uncensored: is_chinese = False
        feature_map = {
            "ä¸­æ–‡å­—å¹•": is_chinese,
            "è‹±æ–‡å­—å¹•": is_english,
            "æ— ç æµå‡º": is_uncensored,
            "æ™®é€š": (not is_chinese and not is_english and not is_uncensored)
        }
        total = len(self.priority_list)
        for idx, name in enumerate(self.priority_list):
            score = (total - idx) * 20
            for key, satisfies in feature_map.items():
                if key in name and satisfies: return score
        return 0

    def _generate_display_title(self, url, title, verified_chinese):
        tags = []
        url_lower = url.lower()
        is_uncensored = "uncensored" in url_lower or "leak" in url_lower or "æ— ç " in title.lower()
        is_chinese = (url in verified_chinese) or ("chinese" in url_lower) or ("ä¸­æ–‡å­—å¹•" in title.lower())
        if is_uncensored:
            tags.append("[æ— ç ]")
            is_chinese = False
        if is_chinese: tags.append("[ä¸­å­—]")
        if "english" in url_lower: tags.append("[è‹±å­—]")
        tag_str = "".join(tags)
        return f"{tag_str} {title}" if tag_str else title


# app/ui/dialogs.py

from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QPushButton,
                             QTableWidget, QTableWidgetItem, QHeaderView,
                             QLabel, QCheckBox, QFrame)
from PyQt6.QtCore import Qt
from app.ui.styles import DARK_STYLESHEET

class SelectionDialog(QDialog):
    # é€šç”¨ä»»åŠ¡é€‰æ‹©å¼¹çª—
    # ç”¨äºåœ¨çˆ¬å–åˆ°é“¾æ¥åˆ—è¡¨åï¼Œè®©ç”¨æˆ·å‹¾é€‰éœ€è¦ä¸‹è½½çš„é¡¹ç›®
    def __init__(self, parent, title="ä»»åŠ¡æ¸…å•ç¡®è®¤", items=None):
        # :param items: list of dict, e.g. [{"title": "è§†é¢‘A", "status": "å¾…ä¸‹è½½"}, ...]
        super().__init__(parent)
        self.setWindowTitle(title)
        self.resize(800, 600)
        self.selected_indices = []
        self.items = items or []
        # åº”ç”¨æš—é»‘ä¸»é¢˜
        self.setStyleSheet(DARK_STYLESHEET)
        self.init_ui()
    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(15)
        # 1. é¡¶éƒ¨æç¤º
        header = QLabel(f"ğŸ“‹ å…±æ‰«æåˆ° {len(self.items)} ä¸ªèµ„æºï¼Œè¯·å‹¾é€‰éœ€è¦ä¸‹è½½çš„é¡¹ç›®ï¼š")
        header.setStyleSheet("font-size: 14px; font-weight: bold; color: #e0e0e0;")
        layout.addWidget(header)
        # 2. åˆ—è¡¨åŒºåŸŸ
        self.table = QTableWidget()
        self.table.setColumnCount(2)
        self.table.setHorizontalHeaderLabels(["é€‰æ‹©", "è§†é¢‘æ ‡é¢˜ / æè¿°"])
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.table.setColumnWidth(0, 60)
        self.table.verticalHeader().setVisible(False)
        self.table.setAlternatingRowColors(True)
        self.table.setStyleSheet("border: 1px solid #333; background-color: #1e1e1e;")
        self.populate_table()
        layout.addWidget(self.table)
        # 3. åº•éƒ¨æŒ‰é’®åŒº
        btn_box = QFrame()
        btn_layout = QHBoxLayout(btn_box)
        btn_layout.setContentsMargins(0, 0, 0, 0)
        # å·¦ä¾§æ“ä½œ
        self.btn_all = QPushButton("å…¨é€‰")
        self.btn_invert = QPushButton("åé€‰")
        self.btn_all.setFixedSize(80, 30)
        self.btn_invert.setFixedSize(80, 30)
        self.btn_all.clicked.connect(self.select_all)
        self.btn_invert.clicked.connect(self.select_invert)
        btn_layout.addWidget(self.btn_all)
        btn_layout.addWidget(self.btn_invert)
        btn_layout.addStretch()
        # å³ä¾§ç¡®è®¤
        self.btn_cancel = QPushButton("å–æ¶ˆä»»åŠ¡")
        self.btn_cancel.setObjectName("DangerBtn")
        self.btn_cancel.setFixedSize(100, 35)
        self.btn_cancel.clicked.connect(self.reject) # å…³é—­å¹¶è¿”å› Rejected
        self.btn_confirm = QPushButton("â¬‡ï¸ å¼€å§‹ä¸‹è½½")
        self.btn_confirm.setObjectName("PrimaryBtn")
        self.btn_confirm.setFixedSize(120, 35)
        self.btn_confirm.clicked.connect(self.confirm_selection)
        btn_layout.addWidget(self.btn_cancel)
        btn_layout.addWidget(self.btn_confirm)
        layout.addWidget(btn_box)
    def populate_table(self):
        self.table.setRowCount(len(self.items))
        for i, item_data in enumerate(self.items):
            # å¤é€‰æ¡†åˆ— (å±…ä¸­)
            chk_widget = QFrame()
            chk_layout = QHBoxLayout(chk_widget)
            chk_layout.setContentsMargins(0,0,0,0)
            chk_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
            chk = QCheckBox()
            chk.setChecked(True) # é»˜è®¤å…¨é€‰
            chk_layout.addWidget(chk)
            self.table.setCellWidget(i, 0, chk_widget)
            # æ ‡é¢˜åˆ—
            title_item = QTableWidgetItem(item_data.get('title', 'æœªçŸ¥æ ‡é¢˜'))
            title_item.setFlags(title_item.flags() ^ Qt.ItemFlag.ItemIsEditable) # åªè¯»
            self.table.setItem(i, 1, title_item)
    def select_all(self):
        for i in range(self.table.rowCount()):
            widget = self.table.cellWidget(i, 0)
            chk = widget.findChild(QCheckBox)
            chk.setChecked(True)
    def select_invert(self):
        for i in range(self.table.rowCount()):
            widget = self.table.cellWidget(i, 0)
            chk = widget.findChild(QCheckBox)
            chk.setChecked(not chk.isChecked())
    def confirm_selection(self):
        self.selected_indices = []
        for i in range(self.table.rowCount()):
            widget = self.table.cellWidget(i, 0)
            chk = widget.findChild(QCheckBox)
            if chk.isChecked():
                self.selected_indices.append(i)
        self.accept() # å…³é—­å¹¶è¿”å› Accepted


# app/ui/main_window.py

import os

from PyQt6.QtGui import QTextCursor
from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
                             QLabel, QLineEdit, QPushButton, QProgressBar,
                             QTableWidget, QTableWidgetItem, QHeaderView,
                             QFrame, QSplitter, QPlainTextEdit, QComboBox,
                             QFileDialog, QStyle, QSlider, QSizePolicy, QDialog, QMessageBox)
from PyQt6.QtCore import Qt, pyqtSignal, QUrl, QSize, QByteArray
from PyQt6.QtMultimedia import QMediaPlayer, QAudioOutput
from PyQt6.QtMultimediaWidgets import QVideoWidget

from app.ui.styles import DARK_STYLESHEET
from app.utils import cfg
from app.core.registry import registry
from app.ui.dialogs import SelectionDialog


class ClickableVideoWidget(QVideoWidget):
    sig_double_click = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setStyleSheet("background-color: #000; border-top-left-radius: 4px; border-top-right-radius: 4px;")

    def mouseDoubleClickEvent(self, event):
        self.sig_double_click.emit()


class MainWindow(QMainWindow):
    sig_start_crawl = pyqtSignal(str, str, dict)
    sig_stop_crawl = pyqtSignal()
    sig_change_dir = pyqtSignal()
    sig_play_video = pyqtSignal(str)
    sig_delete_video = pyqtSignal(int, str)

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Universal Crawler Pro")
        self.resize(1300, 850)
        self.setStyleSheet(DARK_STYLESHEET)

        self.current_save_dir = cfg.get("common", "save_directory") or os.getcwd()
        self.current_plugin = None
        self.plugin_widget = None
        self.is_fullscreen_mode = False

        self.init_ui()
        # å»¶è¿ŸåŠ è½½çŠ¶æ€
        self.load_initial_state()

    def init_ui(self):
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        main_layout.setContentsMargins(10, 10, 10, 10)
        main_layout.setSpacing(10)

        # === [A] TopBar ===
        self.top_bar = QFrame()
        self.top_bar.setObjectName("TopBar")
        self.top_bar.setFixedHeight(50)

        top_layout = QHBoxLayout(self.top_bar)
        top_layout.setContentsMargins(10, 5, 10, 5)
        top_layout.setSpacing(10)
        top_layout.setAlignment(Qt.AlignmentFlag.AlignVCenter)

        self.combo_source = QComboBox()
        self.plugins_list = registry.get_all_plugins()
        for p in self.plugins_list:
            self.combo_source.addItem(p.name, p.id)
        self.combo_source.setSizeAdjustPolicy(QComboBox.SizeAdjustPolicy.AdjustToContents)
        self.combo_source.setMinimumWidth(120)
        self.combo_source.setFixedHeight(30)
        self.combo_source.currentIndexChanged.connect(self.on_source_changed)
        top_layout.addWidget(self.combo_source)

        self.inp_search = QLineEdit()
        self.inp_search.setMinimumWidth(200)
        self.inp_search.setFixedHeight(30)
        self.inp_search.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Fixed)
        top_layout.addWidget(self.inp_search)

        self.container_dynamic = QWidget()
        self.layout_dynamic = QHBoxLayout(self.container_dynamic)
        self.layout_dynamic.setContentsMargins(0, 0, 0, 0)
        self.layout_dynamic.setSpacing(10)
        top_layout.addWidget(self.container_dynamic)

        self.btn_start = QPushButton("ğŸš€ å¯åŠ¨ä»»åŠ¡")
        self.btn_start.setObjectName("PrimaryBtn")
        self.btn_start.setFixedHeight(30)
        self.btn_start.setMinimumWidth(100)
        self.btn_start.clicked.connect(self.on_btn_start_clicked)
        top_layout.addWidget(self.btn_start)

        self.btn_stop = QPushButton("ğŸ›‘ åœæ­¢")
        self.btn_stop.setObjectName("DangerBtn")
        self.btn_stop.setEnabled(False)
        self.btn_stop.setFixedHeight(30)
        self.btn_stop.setMinimumWidth(80)
        self.btn_stop.clicked.connect(lambda: self.sig_stop_crawl.emit())
        top_layout.addWidget(self.btn_stop)

        self.btn_dir = QPushButton("ğŸ“‚ æ›´æ”¹ç›®å½•")
        self.btn_dir.setObjectName("DirBtn")
        self.btn_dir.setFixedHeight(30)
        self.btn_dir.setMinimumWidth(100)
        self.btn_dir.clicked.connect(self.on_btn_dir_clicked)
        top_layout.addWidget(self.btn_dir)

        main_layout.addWidget(self.top_bar)

        # === [B] Splitter (ä¸»åˆ†å‰²çº¿: å·¦å³) ===
        self.main_split = QSplitter(Qt.Orientation.Horizontal)
        self.main_split.setHandleWidth(4)

        # --- Left Panel ---
        self.left_panel = QFrame()
        self.left_panel.setObjectName("ContentPanel")
        ll = QVBoxLayout(self.left_panel)
        ll.setContentsMargins(0, 0, 0, 0)
        ll.setSpacing(0)

        header_bar = QFrame()
        header_bar.setObjectName("HeaderBar")
        header_bar.setFixedHeight(35)
        hl = QHBoxLayout(header_bar)
        hl.setContentsMargins(10, 0, 10, 0)
        hl.setAlignment(Qt.AlignmentFlag.AlignVCenter)
        hl.addWidget(QLabel("ğŸ“‹ ä¸‹è½½é˜Ÿåˆ—"))
        hl.addWidget(QLabel(" | ä¿å­˜è‡³: ", styleSheet="color: #888;"))
        self.lbl_full_path = QLabel(self.current_save_dir)
        self.lbl_full_path.setObjectName("PathLabel")
        self.lbl_full_path.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        hl.addWidget(self.lbl_full_path)
        ll.addWidget(header_bar)

        self.table = QTableWidget()
        self.table.setColumnCount(4)
        self.table.setHorizontalHeaderLabels(["è§†é¢‘æ ‡é¢˜", "çŠ¶æ€", "è¿›åº¦", "æ“ä½œ"])
        self.table.verticalHeader().setVisible(False)
        self.table.setShowGrid(False)
        self.table.setAlternatingRowColors(True)
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.table.setFrameShape(QFrame.Shape.NoFrame)
        self.table.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOn)

        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.Fixed)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.Fixed)
        self.table.setColumnWidth(1, 80)
        self.table.setColumnWidth(2, 100)
        self.table.setColumnWidth(3, 80)
        ll.addWidget(self.table)

        self.main_split.addWidget(self.left_panel)

        # --- Right Panel ---
        # è¿™æ˜¯ä¸€ä¸ªå®¹å™¨ï¼Œé‡Œé¢æ”¾ right_split
        right_container = QWidget()
        right_layout = QVBoxLayout(right_container)
        right_layout.setContentsMargins(0, 0, 0, 0)
        right_layout.setSpacing(0)

        # [æ ¸å¿ƒ] å³ä¾§åˆ†å‰²çº¿ (ä¸Šä¸‹)
        self.right_split = QSplitter(Qt.Orientation.Vertical)
        self.right_split.setHandleWidth(4)

        # 1. ä¸ŠåŠéƒ¨åˆ†ï¼šè§†é¢‘ + æ§åˆ¶æ¡
        video_container = QFrame()
        video_container.setObjectName("ContentPanel")
        vl = QVBoxLayout(video_container)
        vl.setContentsMargins(0, 0, 0, 0)
        vl.setSpacing(0)

        self.vid_w = ClickableVideoWidget()
        self.vid_w.sig_double_click.connect(self.toggle_fullscreen_mode)

        self.player = QMediaPlayer()
        self.audio = QAudioOutput()
        self.player.setAudioOutput(self.audio)
        self.player.setVideoOutput(self.vid_w)

        self.ctrls = QFrame()
        self.ctrls.setFixedHeight(50)
        self.ctrls.setStyleSheet("background:#252526; border-top: 1px solid #333;")
        cl = QHBoxLayout(self.ctrls)
        cl.setContentsMargins(15, 0, 15, 0)
        cl.setSpacing(15)

        self.btn_play = QPushButton()
        self.btn_play.setFixedSize(32, 32)
        self.btn_play.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPlay))
        self.btn_play.setStyleSheet("border-radius: 16px; background-color: #333; border: 1px solid #444;")
        self.btn_play.clicked.connect(self.toggle_play)

        self.slider = QSlider(Qt.Orientation.Horizontal)
        self.slider.sliderPressed.connect(lambda: setattr(self, 'is_slider_pressed', True))
        self.slider.sliderReleased.connect(self.on_slider_released)
        self.player.positionChanged.connect(self.on_player_position_changed)
        self.player.durationChanged.connect(lambda d: self.slider.setRange(0, d))

        self.lbl_time = QLabel("00:00")
        self.lbl_time.setStyleSheet("color: #aaa; font-family: Consolas;")

        self.btn_fullscreen = QPushButton("[ å…¨å± ]")
        self.btn_fullscreen.setFixedSize(60, 32)
        self.btn_fullscreen.setStyleSheet(
            "border-radius: 4px; background-color: #333; border: 1px solid #444; color: #eee; font-size: 12px;")
        self.btn_fullscreen.setToolTip("æ²‰æµ¸æ¨¡å¼ (åŒå‡»ç”»é¢)")
        self.btn_fullscreen.clicked.connect(self.toggle_fullscreen_mode)

        cl.addWidget(self.btn_play)
        cl.addWidget(self.slider)
        cl.addWidget(self.lbl_time)
        cl.addWidget(self.btn_fullscreen)

        vl.addWidget(self.vid_w)
        vl.addWidget(self.ctrls)

        # 2. ä¸‹åŠéƒ¨åˆ†ï¼šæ—¥å¿—
        self.log_txt = QPlainTextEdit()
        self.log_txt.setReadOnly(True)
        self.log_txt.setStyleSheet("border-top: 1px solid #333; background-color: #111; color: #eee;")
        self.log_txt.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOn)

        # æ·»åŠ åˆ°å³ä¾§åˆ†å‰²çº¿
        self.right_split.addWidget(video_container)
        self.right_split.addWidget(self.log_txt)

        # æ·»åŠ åˆ°å³ä¾§å®¹å™¨
        right_layout.addWidget(self.right_split)

        # æ·»åŠ åˆ°ä¸»åˆ†å‰²çº¿
        self.main_split.addWidget(right_container)
        main_layout.addWidget(self.main_split)

    # --- Logic ---

    def toggle_fullscreen_mode(self):
        if not self.is_fullscreen_mode:
            self.top_bar.hide()
            self.left_panel.hide()
            self.log_txt.hide()
            self.showFullScreen()
            self.layout().setContentsMargins(0, 0, 0, 0)
            self.is_fullscreen_mode = True
            self.btn_fullscreen.setText("[ é€€å‡º ]")
        else:
            self.top_bar.show()
            self.left_panel.show()
            self.log_txt.show()
            self.showNormal()
            self.layout().setContentsMargins(10, 10, 10, 10)
            self.is_fullscreen_mode = False
            self.btn_fullscreen.setText("[ å…¨å± ]")

            # æ¢å¤æœ€å¤§åŒ–
            state_hex = cfg.get("ui", "window_state")
            if state_hex: self.restoreState(QByteArray.fromHex(state_hex.encode()))

    def keyPressEvent(self, event):
        if event.key() == Qt.Key.Key_Escape and self.is_fullscreen_mode:
            self.toggle_fullscreen_mode()
            event.accept()
        else:
            super().keyPressEvent(event)

    def load_initial_state(self):
        # 1. æ¨¡å¼
        last_source_id = cfg.get("common", "last_source", "kuaishou")
        idx = self.combo_source.findData(last_source_id)
        if idx != -1:
            self.combo_source.setCurrentIndex(idx)
        else:
            self.combo_source.setCurrentIndex(0)
        self.on_source_changed(self.combo_source.currentIndex())

        self.lbl_full_path.setText(self.current_save_dir)
        self.lbl_full_path.setToolTip(self.current_save_dir)

        # 2. çª—å£ä½ç½®
        geo_hex = cfg.get("ui", "geometry")
        if geo_hex: self.restoreGeometry(QByteArray.fromHex(geo_hex.encode()))

        # 3. çª—å£çŠ¶æ€
        state_hex = cfg.get("ui", "window_state")
        if state_hex: self.restoreState(QByteArray.fromHex(state_hex.encode()))

        # 4. ä¸»åˆ†å‰²çº¿ (å·¦å³)
        main_split_hex = cfg.get("ui", "main_splitter_state")
        if main_split_hex:
            self.main_split.restoreState(QByteArray.fromHex(main_split_hex.encode()))
        else:
            self.main_split.setSizes([400, 900])

        # 5. [æ ¸å¿ƒä¿®å¤] å³ä¾§åˆ†å‰²çº¿ (ä¸Šä¸‹)
        right_split_hex = cfg.get("ui", "right_splitter_state")
        if right_split_hex:
            self.right_split.restoreState(QByteArray.fromHex(right_split_hex.encode()))
        else:
            self.right_split.setSizes([600, 200])  # é»˜è®¤ 3:1

    def closeEvent(self, e):
        # [æ ¸å¿ƒä¿®å¤] ä¿å­˜ä¸¤ä¸ªåˆ†å‰²çº¿
        cfg.save_ui_state(
            geometry=self.saveGeometry(),
            state=self.saveState(),
            main_splitter=self.main_split.saveState(),
            right_splitter=self.right_split.saveState(),
            is_fs=self.is_fullscreen_mode
        )
        e.accept()

    def on_btn_start_clicked(self):
        if not self.current_plugin:
            self.append_log("âŒ æœªé€‰æ‹©æœ‰æ•ˆæ¨¡å¼")
            return

        keyword = self.inp_search.text().strip()
        if not keyword:
            self.append_log("âš ï¸ è¯·è¾“å…¥æœç´¢å†…å®¹ï¼")
            return

        run_options = {}
        if self.plugin_widget:
            try:
                run_options = self.current_plugin.get_run_options(self.plugin_widget)
            except Exception as e:
                self.append_log(f"âŒ é…ç½®è¯»å–é”™è¯¯: {e}")
                return

        self.sig_start_crawl.emit(keyword, self.current_plugin.id, run_options)

        self.btn_start.setEnabled(False)
        self.btn_stop.setEnabled(True)
        self.inp_search.setEnabled(False)
        self.combo_source.setEnabled(False)
        if self.plugin_widget: self.plugin_widget.setEnabled(False)

    # --- ä¸šåŠ¡é€»è¾‘ ---
    def on_source_changed(self, index):
        plugin_id = self.combo_source.currentData()
        if not plugin_id: return

        self.current_plugin = registry.get_plugin(plugin_id)
        if not self.current_plugin: return

        self.inp_search.setPlaceholderText(self.current_plugin.get_search_placeholder())

        while self.layout_dynamic.count():
            item = self.layout_dynamic.takeAt(0)
            if item.widget(): item.widget().deleteLater()

        self.plugin_widget = self.current_plugin.get_settings_widget(self.container_dynamic)
        if self.plugin_widget:
            self.layout_dynamic.addWidget(self.plugin_widget)
            self.plugin_widget.show()

        cfg.set("common", "last_source", plugin_id)

    def on_btn_dir_clicked(self):
        d = QFileDialog.getExistingDirectory(self, "é€‰æ‹©ä¿å­˜ç›®å½•", self.current_save_dir)
        if d:
            self.current_save_dir = d
            self.lbl_full_path.setText(d)
            self.lbl_full_path.setToolTip(d)
            cfg.set("common", "save_directory", d)
            self.sig_change_dir.emit()

    def add_video_row(self, video_item):
        row = self.table.rowCount()
        self.table.insertRow(row)
        t_item = QTableWidgetItem(video_item.title)
        t_item.setData(Qt.ItemDataRole.UserRole, video_item.id)
        t_item.setToolTip(video_item.title)
        self.table.setItem(row, 0, t_item)
        s_item = QTableWidgetItem(video_item.status)
        s_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
        self.table.setItem(row, 1, s_item)
        pb = QProgressBar()
        pb.setValue(video_item.progress)
        self.table.setCellWidget(row, 2, pb)
        op_widget = QWidget()
        op_layout = QHBoxLayout(op_widget)
        op_layout.setContentsMargins(0, 0, 0, 0)
        op_layout.setSpacing(5)
        op_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        btn_p = QPushButton()
        btn_p.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPlay))
        btn_p.setFixedSize(26, 24)
        btn_p.clicked.connect(lambda: self.sig_play_video.emit(video_item.id))
        btn_d = QPushButton()
        btn_d.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_TrashIcon))
        btn_d.setFixedSize(26, 24)
        btn_d.clicked.connect(lambda: self.sig_delete_video.emit(row, video_item.id))
        op_layout.addWidget(btn_p)
        op_layout.addWidget(btn_d)
        self.table.setCellWidget(row, 3, op_widget)

    def update_video_status(self, video_id, status, progress=None):
        for r in range(self.table.rowCount()):
            item = self.table.item(r, 0)
            if item and item.data(Qt.ItemDataRole.UserRole) == video_id:
                self.table.item(r, 1).setText(status)
                if progress is not None: self.table.cellWidget(r, 2).setValue(progress)
                break

    def refresh_table_bindings(self):
        for r in range(self.table.rowCount()):
            item = self.table.item(r, 0)
            if not item: continue
            vid = item.data(Qt.ItemDataRole.UserRole)
            widget = self.table.cellWidget(r, 3)
            if widget:
                layout = widget.layout()
                for i in range(layout.count()):
                    widget_item = layout.itemAt(i).widget()
                    if isinstance(widget_item, QPushButton):
                        if i == 1:
                            try:
                                widget_item.clicked.disconnect()
                            except:
                                pass
                            widget_item.clicked.connect(
                                lambda checked, row=r, v=vid: self.sig_delete_video.emit(row, v))

    def show_selection_dialog(self, items):
        dlg = SelectionDialog(self, items=items)
        if dlg.exec() == QDialog.DialogCode.Accepted:
            self.append_log(f"âœ… ç”¨æˆ·ç¡®è®¤äº† {len(dlg.selected_indices)} ä¸ªä»»åŠ¡")
            return dlg.selected_indices
        else:
            self.append_log("âŒ ç”¨æˆ·å–æ¶ˆäº†ä»»åŠ¡")
            return None

    def append_log(self, msg):
        self.log_txt.appendHtml(f'<span style="color:#aaa;">{msg}</span>')
        self.log_txt.moveCursor(QTextCursor.MoveOperation.End)

    def toggle_play(self):
        if self.player.playbackState() == QMediaPlayer.PlaybackState.PlayingState:
            self.player.pause()
            self.btn_play.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPlay))
        else:
            self.player.play()
            self.btn_play.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_MediaPause))

    def on_slider_released(self):
        self.is_slider_pressed = False
        self.player.setPosition(self.slider.value())

    def on_player_position_changed(self, pos):
        if not getattr(self, 'is_slider_pressed', False):
            self.slider.setValue(pos)
        self.lbl_time.setText(f"{self.format_time(pos)} / {self.format_time(self.player.duration())}")

    def format_time(self, ms):
        seconds = (ms // 1000) % 60
        minutes = (ms // 60000)
        return f"{minutes:02}:{seconds:02}"



# app/ui/styles.py

COLOR_BG = "#181818"
COLOR_PANEL = "#1e1e1e"
COLOR_INPUT = "#252526"
COLOR_ACCENT = "#007acc"
COLOR_DANGER = "#C92C2C"
COLOR_TEXT = "#e0e0e0"
COLOR_BORDER = "#333333"

DARK_STYLESHEET = f"""
QMainWindow, QWidget {{
    background-color: {COLOR_BG};
    color: {COLOR_TEXT};
    font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
    font-size: 13px;
}}
/* ================= é¡¶éƒ¨å·¥å…·æ  ================= */
QFrame#TopBar {{
    background-color: {COLOR_PANEL};
    border: none;
    border-bottom: 1px solid {COLOR_BORDER};
    margin: 0px;
    padding: 0px;
}}
/* ================= å·¦ä¾§/å³ä¾§ é¢æ¿å®¹å™¨ ================= */
QFrame#ContentPanel {{
    background-color: {COLOR_PANEL};
    border: 1px solid {COLOR_BORDER};
    border-radius: 4px;
}}
/* ================= åˆ—è¡¨æ ‡é¢˜æ  (å­˜æ”¾è·¯å¾„) ================= */
QFrame#HeaderBar {{
    background-color: #252526;
    border-bottom: 1px solid {COLOR_BORDER};
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}}
/* è·¯å¾„æ–‡å­—é«˜äº® */
QLabel#PathLabel {{
    color: {COLOR_ACCENT};
    font-family: 'Consolas', monospace;
    font-weight: bold;
    padding-left: 5px;
}}
/* ================= è¾“å…¥ç»„ä»¶ ================= */
QLineEdit {{
    border: 1px solid {COLOR_BORDER};
    border-radius: 4px;
    background-color: {COLOR_INPUT};
    color: #fff;
    padding: 4px;
}}
QLineEdit:focus {{ border: 1px solid {COLOR_ACCENT}; }}
QComboBox {{
    border: 1px solid {COLOR_BORDER};
    border-radius: 4px;
    background-color: {COLOR_INPUT};
    padding: 4px;
}}
/* ================= æŒ‰é’® ================= */
QPushButton {{
    background-color: #2d2d2d;
    border: 1px solid {COLOR_BORDER};
    border-radius: 4px;
    color: #eee;
    padding: 5px 15px; /* å¢åŠ å·¦å³å†…è¾¹è·ï¼Œé˜²æ­¢æ–‡å­—æˆªæ–­ */
}}
QPushButton:hover {{ background-color: #3e3e3e; }}
QPushButton:pressed {{ background-color: #222; }}
QPushButton#PrimaryBtn {{
    background-color: {COLOR_ACCENT};
    border: none;
    font-weight: bold;
}}
QPushButton#PrimaryBtn:hover {{ background-color: #0062a3; }}
QPushButton#DangerBtn {{
    background-color: {COLOR_DANGER};
    border: none;
    font-weight: bold;
}}
QPushButton#DangerBtn:hover {{ background-color: #992222; }}
QPushButton#DangerBtn:disabled {{
    background-color: #2d2d2d;
    color: #555;
    border: 1px solid {COLOR_BORDER};
}}

QPushButton#DirBtn {{
    background-color: {COLOR_INPUT};
    border: 1px dashed #555;
    color: #aaa;
    text-align: left;
}}
QPushButton#DirBtn:hover {{
    border: 1px dashed {COLOR_ACCENT};
    color: #fff;
    background-color: #2d2d2d;
}}

/* ================= å…¶ä»– ================= */
QProgressBar {{
    border: 1px solid {COLOR_BORDER};
    border-radius: 3px;
    background-color: {COLOR_INPUT};
    text-align: center;
    font-size: 11px;
}}
QProgressBar::chunk {{ background-color: {COLOR_ACCENT}; }}
QSplitter::handle {{ background-color: {COLOR_BG}; }}
QSplitter::handle:hover {{ background-color: {COLOR_ACCENT}; }}

/* æ»šåŠ¨æ¡ (äº®è‰²æ»‘å—) */
QScrollBar:vertical {{ background: #111; width: 12px; margin: 0px; }}
QScrollBar::handle:vertical {{ background: #888; min-height: 20px; border-radius: 4px; }}
QScrollBar::handle:vertical:hover {{ background: #fff; }}
QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{ height: 0px; }}
QScrollBar:horizontal {{ background: #111; height: 12px; margin: 0px; }}
QScrollBar::handle:horizontal {{ background: #888; min-width: 20px; border-radius: 4px; }}
QScrollBar::handle:horizontal:hover {{ background: #fff; }}
QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{ height: 0px; }}
"""


# app/models.py

import time
import random
import re
from dataclasses import dataclass, field
from typing import Dict, Optional

@dataclass
class VideoItem:
    """
    ç»Ÿä¸€è§†é¢‘æ•°æ®æ¨¡å‹
    ç”¨äºåœ¨çˆ¬è™«çº¿ç¨‹ã€UIä¸»çº¿ç¨‹å’Œä¸‹è½½çº¿ç¨‹ä¹‹é—´ä¼ é€’æ•°æ®
    """
    # æ ¸å¿ƒå­—æ®µ
    url: str
    title: str
    source: str         # 'missav' æˆ– 'kuaishou'
    # çŠ¶æ€å­—æ®µ
    id: str = field(init=False)      # å”¯ä¸€æ ‡è¯†ç¬¦
    status: str = "waiting"          # waiting, downloading, finished, error
    progress: int = 0
    local_path: str = ""             # ä¸‹è½½åçš„æœ¬åœ°ç»å¯¹è·¯å¾„
    # å…ƒæ•°æ® (ç”¨äºå­˜å‚¨ç‰¹å®šæ¥æºçš„ç‰¹æ®Šä¿¡æ¯)
    # MissAV: å­˜å‚¨ header, proxy, æ ‡ç­¾(tags), åˆ†æ•°(score)
    # å¿«æ‰‹: å­˜å‚¨ author, åŸå§‹ headers
    meta: Dict = field(default_factory=dict)
    def __post_init__(self):
        """åˆå§‹åŒ–åè‡ªåŠ¨ç”Ÿæˆå”¯ä¸€ID"""
        # ç”Ÿæˆè§„åˆ™ï¼šæ¯«ç§’çº§æ—¶é—´æˆ³ + 3ä½éšæœºæ•°ï¼Œç¡®ä¿åŒä¸€æ¯«ç§’å†…çš„å¹¶å‘ä¹Ÿä¸ä¼šé‡å¤
        self.id = f"{int(time.time() * 1000)}_{random.randint(100, 999)}"
        # å»é™¤æ ‡é¢˜é¦–å°¾ç©ºæ ¼
        if self.title:
            self.title = self.title.strip()
    def get_safe_filename(self, extension: str = ".mp4") -> str:
        # æ ¸å¿ƒä¿®å¤ï¼šç”Ÿæˆå®‰å…¨ä¸”å”¯ä¸€çš„æ–‡ä»¶å
        # è§£å†³åŸé¡¹ç›®ä¸­æ ‡é¢˜ä¸ºç©ºæ—¶æ–‡ä»¶è¦†ç›–çš„é—®é¢˜
        # 1. è·å–åŸºç¡€æ ‡é¢˜
        raw_name = self.title
        # 2. å¦‚æœæ˜¯ MissAVï¼Œå°è¯•è¿½åŠ æ ‡ç­¾åç¼€ (å®Œå…¨å¤åˆ»è™¾ç‰‡.pyçš„å‘½åé€»è¾‘)
        # ä¾‹å¦‚: "ABP-123 [ä¸­æ–‡å­—å¹•]"
        if self.source == "missav":
            tags = self.meta.get("tags", [])
            suffix = ""
            if "ä¸­æ–‡å­—å¹•" in tags: suffix = " [ä¸­æ–‡å­—å¹•]"
            elif "è‹±æ–‡å­—å¹•" in tags: suffix = " [è‹±æ–‡å­—å¹•]"
            elif "æ— ç æµå‡º" in tags: suffix = " [æ— ç ]"
            raw_name += suffix
        # 3. æ¸…ç†éæ³•å­—ç¬¦ (Windows/Linux æ–‡ä»¶åé™åˆ¶)
        # æ›¿æ¢ \ / : * ? " < > | ä¸ºä¸‹åˆ’çº¿
        safe_name = re.sub(r'[\\/:*?"<>|]', '_', raw_name).strip()
        # 4. ã€å…³é”®ä¿®å¤ã€‘å¦‚æœæ¸…ç†åæ ‡é¢˜ä¸ºç©ºï¼Œæˆ–è€…åŸå§‹æ ‡é¢˜å°±æ˜¯ç©ºçš„
        # å¼ºåˆ¶ä½¿ç”¨ "æ¥æº_ID" ä½œä¸ºæ–‡ä»¶åï¼Œä¿è¯ç»å¯¹å”¯ä¸€
        if not safe_name:
            safe_name = f"{self.source}_UNKNOWN_{self.id}"
        # 5. é™åˆ¶æ–‡ä»¶åé•¿åº¦ (é˜²æ­¢æ“ä½œç³»ç»ŸæŠ¥é”™)
        if len(safe_name) > 220:
            safe_name = safe_name[:220]
        # 6. ç¡®ä¿åç¼€åæ­£ç¡®
        if not extension.startswith("."):
            extension = f".{extension}"
        return f"{safe_name}{extension}"
    def update_from_dict(self, data: dict):
        """ä»å­—å…¸æ›´æ–°å±æ€§ (ä¾¿äºä»é…ç½®æˆ–ä¸´æ—¶å¯¹è±¡æ¢å¤)"""
        for k, v in data.items():
            if hasattr(self, k):
                setattr(self, k, v)
# ================= è¾…åŠ©ç±» =================
class AppConfig:
    """ç®€å•çš„é…ç½®æŒæœ‰ç±»ï¼Œç”¨äºåœ¨å„æ¨¡å—é—´ä¼ é€’ç”¨æˆ·è®¾ç½®"""
    def __init__(self):
        # é€šç”¨è·¯å¾„
        self.save_dir = ""
        # MissAV ä¸“å±é…ç½®
        self.missav_proxy = "http://127.0.0.1:7890"  # é»˜è®¤ä»£ç†
        self.missav_individual_only = False          # ä»…å•ä½“
        self.missav_sort_priority = ["ä¸­æ–‡å­—å¹•", "è‹±æ–‡å­—å¹•", "æ— ç æµå‡º", "æ™®é€šç‰ˆ"] # æ’åºåå¥½


# app/utils.py

import os
import json
import re
import shutil
from datetime import time
from PyQt6.QtCore import QByteArray

class ConfigManager:
    def __init__(self, filename="config.json"):
        self.filename = filename
        self.data = self._load_defaults()
        self._load_from_disk()
    def _load_defaults(self):
        return {
            "common": {
                "save_directory": os.path.join(os.getcwd(), "Downloads"),
                "last_source": "kuaishou",
                "theme": "dark"
            },
            "missav": {
                "proxy_app": "Clash (7890)",
                "proxy_url": "http://127.0.0.1:7890",
                "priority": "ä¸­æ–‡å­—å¹•ä¼˜å…ˆ",
                "individual_only": False
            },
            "bilibili": {
                "auth_file": "bili_auth.json",  # è‡ªåŠ¨ä¿å­˜çš„ Cookie æ–‡ä»¶
                "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
            },
            "ui": {
                "geometry": "",
                "window_state": "",
                "splitter_state": "",
                "main_splitter_state": "",
                "right_splitter_state": "",
                "is_fullscreen_mode": False
            }
        }
    def _load_from_disk(self):
        if not os.path.exists(self.filename):
            self.save()
            return
        try:
            with open(self.filename, 'r', encoding='utf-8') as f:
                saved_data = json.load(f)
                self._recursive_update(self.data, saved_data)
        except Exception as e:
            print(f"âš ï¸ é…ç½®æ–‡ä»¶æŸåæˆ–ä¸å…¼å®¹: {e}")
            self._reset_config()
    def _reset_config(self):
        """å¤‡ä»½åæ–‡ä»¶å¹¶é‡ç½®"""
        if os.path.exists(self.filename):
            backup_name = f"{self.filename}.bak.{int(time.time())}"
            try:
                shutil.move(self.filename, backup_name)
                print(f"âœ… å·²å°†æŸåçš„é…ç½®å¤‡ä»½ä¸º: {backup_name}")
            except: pass
        self.data = self._load_defaults()
        self.save()
    def _recursive_update(self, target, source):
        for k, v in source.items():
            if k in target and isinstance(target[k], dict) and isinstance(v, dict):
                self._recursive_update(target[k], v)
            else:
                # ç±»å‹æ£€æŸ¥ï¼šå¦‚æœä¿å­˜çš„ç±»å‹å’Œé»˜è®¤ç±»å‹ä¸ä¸€è‡´ï¼ˆé™¤äº†Noneï¼‰ï¼Œåˆ™å¿½ç•¥ï¼Œé˜²æ­¢æ³¨å…¥åæ•°æ®
                default_type = type(target.get(k))
                if target.get(k) is not None and v is not None and not isinstance(v, default_type):
                    continue
                target[k] = v
    def save(self):
        try:
            with open(self.filename, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, indent=4, ensure_ascii=False)
        except Exception as e:
            print(f"âŒ ä¿å­˜é…ç½®å¤±è´¥: {e}")
    # --- é€šç”¨ Get/Set ---
    def get(self, section, key, default=None):
        try:
            val = self.data.get(section, {}).get(key)
            return val if val is not None else default
        except:
            return default
    def set(self, section, key, value):
        if section not in self.data: self.data[section] = {}
        self.data[section][key] = value
        self.save()
    # --- UI çŠ¶æ€ä¸“ç”¨ ---
    def save_ui_state(self, geometry: QByteArray, state: QByteArray,
                      main_splitter: QByteArray, right_splitter: QByteArray,
                      is_fs: bool):
        self.data["ui"]["geometry"] = geometry.toHex().data().decode()
        self.data["ui"]["window_state"] = state.toHex().data().decode()
        self.data["ui"]["main_splitter_state"] = main_splitter.toHex().data().decode()
        self.data["ui"]["right_splitter_state"] = right_splitter.toHex().data().decode()
        self.data["ui"]["is_fullscreen_mode"] = is_fs
        self.save()
    def update_missav_proxy(self, app_name, url):
        self.data["missav"]["proxy_app"] = app_name
        self.data["missav"]["proxy_url"] = url
        self.save()
def format_size(size_bytes):
    if size_bytes == 0: return "0 B"
    import math
    if size_bytes < 0: return "Unknown"
    i = int(math.log(size_bytes, 1024))
    p = math.pow(1024, i)
    s = round(size_bytes / p, 2)
    return f"{s} {('B','KB','MB','GB')[i]}"
def sanitize_filename(name):
    return re.sub(r'[\\/:*?"<>|]', '_', str(name)).strip()[:200]
cfg = ConfigManager()



[{"name": "buvid3", "value": "11BEA90E-1458-2603-DB1C-5CDB99F7F1BF60497infoc", "domain": ".bilibili.com", "path": "/", "expires": 1803734560.624923, "httpOnly": false, "secure": false, "sameSite": "Lax"}, {"name": "b_nut", "value": "1769174560", "domain": ".bilibili.com", "path": "/", "expires": 1800710560.625058, "httpOnly": false, "secure": false, "sameSite": "Lax"}, {"name": "bili_ticket", "value": "eyJhbGciOiJIUzI1NiIsImtpZCI6InMwMyIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3Njk0MzM3NjIsImlhdCI6MTc2OTE3NDUwMiwicGx0IjotMX0.iG7dcfY7ScGw-9oFmuPmy2gmjJADA97ZyzcWouPL_Y4", "domain": ".bilibili.com", "path": "/", "expires": 1769433762, "httpOnly": false, "secure": false, "sameSite": "Lax"}, {"name": "bili_ticket_expires", "value": "1769433702", "domain": ".bilibili.com", "path": "/", "expires": 1769433762, "httpOnly": false, "secure": false, "sameSite": "Lax"}, {"name": "buvid4", "value": "B9DF668E-EFCE-EA94-4E02-2DF6F357A32562577-026012321-AFS0PYOHxynvyINItwRQ6g%3D%3D", "domain": ".bilibili.com", "path": "/", "expires": 1803734562.716236, "httpOnly": false, "secure": false, "sameSite": "Lax"}, {"name": "buvid_fp", "value": "457acca5ed5c6cd3d61bec72816fe688", "domain": ".bilibili.com", "path": "/", "expires": 1800710563, "httpOnly": false, "secure": false, "sameSite": "Lax"}, {"name": "SESSDATA", "value": "4dbe149d%2C1784726589%2Cd6992%2A11CjAgZipDEIbBGJpsJo16ewldh8e8TEZULXFujI0xvhnbftHVWzQDGbnT3fCHaMFPIBISVkp5Q3RZNFlBMWZMZUplck9Kb2plSUNIbFN4ZDNDSHFXb2pvN0JjUGZtUFFwVzJ6a1lKYnZYUUtYSlk0cHZsakRTdXV0SXNZbnJOdVBTNFVlRVhDMFVBIIEC", "domain": ".bilibili.com", "path": "/", "expires": 1784726589.296104, "httpOnly": true, "secure": true, "sameSite": "Lax"}, {"name": "bili_jct", "value": "a3b9fa2d72da2b0a6aa94a295b2ddec6", "domain": ".bilibili.com", "path": "/", "expires": 1784726589.296359, "httpOnly": false, "secure": false, "sameSite": "Lax"}, {"name": "DedeUserID", "value": "511776633", "domain": ".bilibili.com", "path": "/", "expires": 1784726589.296488, "httpOnly": false, "secure": false, "sameSite": "Lax"}, {"name": "DedeUserID__ckMd5", "value": "c1b424837ebbc59d", "domain": ".bilibili.com", "path": "/", "expires": 1784726589.296576, "httpOnly": false, "secure": true, "sameSite": "None"}, {"name": "sid", "value": "pwp02c4n", "domain": ".bilibili.com", "path": "/", "expires": 1784726589.296605, "httpOnly": false, "secure": true, "sameSite": "None"}]


{
    "common": {
        "save_directory": "D:/desktop",
        "last_source": "bilibili",
        "theme": "dark"
    },
    "missav": {
        "proxy_app": "Clash (7890)",
        "proxy_url": "http://127.0.0.1:7890",
        "priority": "ä¸­æ–‡å­—å¹•ä¼˜å…ˆ",
        "individual_only": true
    },
    "bilibili": {
        "auth_file": "bili_auth.json",
        "user_agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
    },
    "ui": {
        "geometry": "01d9d0cb0003000000000007000000000000051a0000036f000000070000001e0000051a0000036f000000000000000005a0000000070000001e0000051a0000036f",
        "window_state": "000000ff00000000fd00000000000005140000035200000004000000040000000800000008fc00000000",
        "splitter_state": "",
        "main_splitter_state": "000000ff0000000100000002000001bd0000033f0100000004010000000100",
        "right_splitter_state": "000000ff00000001000000020000020f000000ef0100000004010000000200",
        "is_fullscreen_mode": false
    }
}


{
    "cookies": [
        {
            "name": "kpf",
            "value": "PC_WEB",
            "domain": ".www.kuaishou.com",
            "path": "/",
            "expires": 1800628178.412888,
            "httpOnly": true,
            "secure": false,
            "sameSite": "Lax"
        },
        {
            "name": "clientid",
            "value": "3",
            "domain": ".www.kuaishou.com",
            "path": "/",
            "expires": 1800628178.413125,
            "httpOnly": true,
            "secure": false,
            "sameSite": "Lax"
        },
        {
            "name": "did",
            "value": "web_42039990ecdfe822f3f11d93658e8f93",
            "domain": ".kuaishou.com",
            "path": "/",
            "expires": 1800628178.413207,
            "httpOnly": false,
            "secure": false,
            "sameSite": "Lax"
        },
        {
            "name": "kwpsecproductname",
            "value": "kuaishou-vision",
            "domain": ".kuaishou.com",
            "path": "/",
            "expires": 1771684179,
            "httpOnly": false,
            "secure": false,
            "sameSite": "Lax"
        },
        {
            "name": "userId",
            "value": "3838429755",
            "domain": ".kuaishou.com",
            "path": "/",
            "expires": 1769669565.695116,
            "httpOnly": false,
            "secure": true,
            "sameSite": "None"
        },
        {
            "name": "userId",
            "value": "3838429755",
            "domain": "id.kuaishou.com",
            "path": "/",
            "expires": 1770879165.544671,
            "httpOnly": false,
            "secure": true,
            "sameSite": "None"
        },
        {
            "name": "passToken",
            "value": "ChNwYXNzcG9ydC5wYXNzLXRva2VuEqABSodMLSDe_pzTfWllYDjhSmIBZtOSlZEFvNvn1Qff32VMDVDXnMLYSuL7PcgvA1TeleNi3y1MECmJYuVlzqMDn2VSwc6Rw1krNh1bHWGgwW6NIYHu-XS7yRp2NkcVVYIjeYmuildF-8vo8zx_V6G-ncdcr8ELLJpkoD-yuMkQbZr-iGO_zL2Ih2JMi4JDKKUPK0MYYhbjLVZQ-0Yy7FehmxoSzTHAimK3SJuusJkUOgOfwIyyIiBLVK4vsxAEuaBFS3zOSlfYGvfPo_7o2MavX8Ru66VRnygFMAE",
            "domain": "id.kuaishou.com",
            "path": "/",
            "expires": 1770879165.544726,
            "httpOnly": true,
            "secure": true,
            "sameSite": "None"
        },
        {
            "name": "kuaishou.server.webday7_st",
            "value": "ChprdWFpc2hvdS5zZXJ2ZXIud2ViZGF5Ny5zdBKwAd182YC9XPOKAbwXfiOVIdOjtjAWnObmeudmoq30DrjK8cadFex2M2FnC5tae9TGURogtv0MspvDIkilcyTe1_u8bvEyh9ZfMgo0rW_OcOZQeso5M_zBh3uzvei74HT-FwsKsdAJG0MYkVSLI2x8dskOwqFIGgzNTvyUcDgyIgCj4j8rdmYy4MJfdlPN-K4nB3iCNKj-YrIji2l0cRqz5daTVnrPqBVC6caZXJ7cACcUGhJMg8a21uCwhwxScQ4lMeUhFTYiIAO-LcFMYBgxR5VFIrMHsdYLyfvVNH7GUc8zPZMOxjcpKAUwAQ",
            "domain": "www.kuaishou.com",
            "path": "/",
            "expires": 1769669565.695325,
            "httpOnly": true,
            "secure": true,
            "sameSite": "None"
        },
        {
            "name": "kuaishou.server.webday7_ph",
            "value": "7aa3c69d3dd26418f90f819fd6322d24e467",
            "domain": "www.kuaishou.com",
            "path": "/",
            "expires": 1769669565.695399,
            "httpOnly": false,
            "secure": false,
            "sameSite": "Lax"
        },
        {
            "name": "ktrace-context",
            "value": "1|MS44Nzg0NzI0NTc4Nzk2ODY5LjY2Mzg4MTYxLjE3NjkwOTIxNzg5MDUuMjA5ODM4NzM=|MS44Nzg0NzI0NTc4Nzk2ODY5Ljk2OTU0NDM4LjE3NjkwOTIxNzg5MDUuMjA5ODM4NzQ=|0|webservice-user-growth-node|webservice|true|src-Js",
            "domain": "www.kuaishou.com",
            "path": "/",
            "expires": -1,
            "httpOnly": false,
            "secure": false,
            "sameSite": "Lax"
        },
        {
            "name": "kpn",
            "value": "KUAISHOU_VISION",
            "domain": ".www.kuaishou.com",
            "path": "/",
            "expires": 1800628178.41308,
            "httpOnly": true,
            "secure": false,
            "sameSite": "Lax"
        },
        {
            "name": "kwfv1",
            "value": "PnGU+9+Y8008S+nH0U+0mjPf8fP08f+98f+nLlwnrIP9+Sw/ZFGfzY+eGlGf+f+e4SGfbYP0QfGnLFwBLU80mYGASDG/WlP/bj+BHl+/PMP/zS+ezjGArl80cAPeHAP0zYGfc9+0bfPB8DPnQYP0+SP/Dh+frFP0GFwBGE+nLI+/Z=",
            "domain": ".kuaishou.com",
            "path": "/",
            "expires": 1771684180,
            "httpOnly": false,
            "secure": false,
            "sameSite": "Lax"
        },
        {
            "name": "kwssectoken",
            "value": "G9t6HPvj96wsavbD8RoQbpPPtK8kReiqHpzkbIX9B8l0VwQqwpEsN3OPelYH1qyzEMsH1Xj4U1c54eOU3540wg==",
            "domain": ".kuaishou.com",
            "path": "/",
            "expires": 1769092540,
            "httpOnly": false,
            "secure": false,
            "sameSite": "Lax"
        },
        {
            "name": "kwscode",
            "value": "10051eaba4b351a85f5e7cd1a7a8d2e4d12be582296db3cd133b7afa2c78e711",
            "domain": ".kuaishou.com",
            "path": "/",
            "expires": 1769092540,
            "httpOnly": false,
            "secure": false,
            "sameSite": "Lax"
        }
    ],
    "origins": [
        {
            "origin": "https://www.kuaishou.com",
            "localStorage": [
                {
                    "name": "WEBLOGGER_CHANNEL_SEQ_ID_NORMAL",
                    "value": "22"
                },
                {
                    "name": "OTHER_DEVICE_INCREASE_ID",
                    "value": "59"
                },
                {
                    "name": "kwfv1",
                    "value": "PnGU+9+Y8008S+nH0U+0mjPf8fP08f+98f+nLlwnrIP9+Sw/ZFGfzY+eGlGf+f+e4SGfbYP0QfGnLFwBLU80mYGASDG/WlP/bj+BHl+/PMP/zS+ezjGArl80cAPeHAP0zYGfc9+0bfPB8DPnQYP0+SP/Dh+frFP0GFwBGE+nLI+/Z="
                },
                {
                    "name": "kwai-kernel-id",
                    "value": "{\"value\":2,\"time\":1769092181742}"
                },
                {
                    "name": "WEBLOGGER_V2_SEQ_ID_showEvent",
                    "value": "22"
                },
                {
                    "name": "LOAD_DEVICE_INCREASE_ID",
                    "value": "3"
                },
                {
                    "name": "kwfcv1",
                    "value": "1"
                },
                {
                    "name": "WEBLOGGER_CUSTOM_INCREAMENT_ID_KEY",
                    "value": "7"
                },
                {
                    "name": "WEBLOGGER_INCREAMENT_ID_KEY",
                    "value": "22"
                },
                {
                    "name": "alg",
                    "value": "test"
                }
            ]
        }
    ]
}


# main.py

import sys
import os
import time
from PyQt6.QtWidgets import QApplication, QMessageBox, QTableWidgetItem
from PyQt6.QtCore import QUrl, Qt, QTimer
# å¼•å…¥é¡¹ç›®æ¨¡å—
from app.ui.main_window import MainWindow
from app.core.download_manager import DownloadManager
from app.core.registry import registry
from app.models import VideoItem
from app.utils import cfg, sanitize_filename

class ApplicationController:
    """
    ä¸»æ§åˆ¶å™¨ (Controller)
    è´Ÿè´£åè°ƒ UIã€çˆ¬è™«é€»è¾‘ã€ä¸‹è½½ç®¡ç†å’Œæ–‡ä»¶ç³»ç»Ÿæ“ä½œ
    """
    def __init__(self):
        # 1. åˆå§‹åŒ– Qt åº”ç”¨
        self.app = QApplication(sys.argv)
        # 2. åˆå§‹åŒ–ä¸»çª—å£
        self.window = MainWindow()
        # 3. å†…éƒ¨çŠ¶æ€
        self.videos = {}  # {id: VideoItem} å†…å­˜ä¸­æŒæœ‰è§†é¢‘å¯¹è±¡
        self.current_spider = None
        self.current_playing_id = None  # è®°å½•å½“å‰æ­£åœ¨æ’­æ”¾çš„è§†é¢‘ID
        # 4. åˆå§‹åŒ–ä¸‹è½½ç®¡ç†å™¨ (é»˜è®¤3å¹¶å‘)
        self.dl_manager = DownloadManager(max_concurrent=3)
        # ================= ä¿¡å·è¿æ¥ï¼šUI -> Controller =================
        self.window.sig_start_crawl.connect(self.start_crawl)
        self.window.sig_stop_crawl.connect(self.stop_crawl)
        self.window.sig_change_dir.connect(self.on_dir_changed)
        self.window.sig_play_video.connect(self.play_video)
        self.window.sig_delete_video.connect(self.delete_video)
        # è¿æ¥è¡¨æ ¼é‡å‘½åä¿¡å·
        self.window.table.itemChanged.connect(self.on_rename_video)
        # ================= ä¿¡å·è¿æ¥ï¼šDownloadManager -> Controller =================
        self.dl_manager.task_started.connect(self.on_dl_start)
        self.dl_manager.task_progress.connect(self.on_dl_progress)
        self.dl_manager.task_finished.connect(self.on_dl_finish)
        self.dl_manager.task_error.connect(self.on_dl_error)
        # 5. æ˜¾ç¤ºçª—å£
        self.window.show()
        # å»¶è¿Ÿæ‰§è¡Œæœ¬åœ°æ‰«æï¼Œé˜²æ­¢å¯åŠ¨æ—¶ UI å°šæœªå°±ç»ªå¯¼è‡´å´©æºƒ (0xC0000409)
        QTimer.singleShot(200, self.scan_local_dir)
    # ---------------- æœ¬åœ°æ–‡ä»¶ç®¡ç† ----------------
    def scan_local_dir(self):
        """æ‰«ææœ¬åœ°æ–‡ä»¶ (é™åˆ¶æ•°é‡é˜²æ­¢å´©æºƒ)"""
        directory = self.window.current_save_dir
        self.window.append_log(f"ğŸ“‚ æ­£åœ¨æ‰«æç›®å½•: {directory}")
        if not os.path.exists(directory):
            try:
                os.makedirs(directory)
            except:
                pass
            return
        self.window.table.setRowCount(0)
        self.videos.clear()
        try:
            # 1. è·å–æ‰€æœ‰mp4æ–‡ä»¶
            all_files = [f for f in os.listdir(directory) if f.lower().endswith('.mp4')]
            # 2. æŒ‰ä¿®æ”¹æ—¶é—´å€’åºæ’åˆ— (æœ€æ–°çš„åœ¨å‰)
            all_files.sort(key=lambda x: os.path.getmtime(os.path.join(directory, x)), reverse=True)
            # 3. [é˜²å´©æºƒ] é™åˆ¶æœ€å¤§åŠ è½½æ•°é‡
            MAX_SCAN_COUNT = 1000
            if len(all_files) > MAX_SCAN_COUNT:
                self.window.append_log(f"âš ï¸ è§†é¢‘è¿‡å¤š ({len(all_files)}ä¸ª)ï¼Œä»…åŠ è½½æœ€æ–°çš„ {MAX_SCAN_COUNT} ä¸ªä»¥é˜²å¡é¡¿ã€‚")
                all_files = all_files[:MAX_SCAN_COUNT]
            count = 0
            for f in all_files:
                title = os.path.splitext(f)[0]
                item = VideoItem(url="", title=title, source="local")
                item.status = "âœ… æœ¬åœ°"
                item.progress = 100
                item.local_path = os.path.join(directory, f)
                self.videos[item.id] = item
                self.window.add_video_row(item)
                count += 1
            if count > 0:
                self.window.append_log(f"âœ… å·²åŠ è½½ {count} ä¸ªæœ¬åœ°è§†é¢‘")
            else:
                self.window.append_log("â„¹ï¸ è¯¥ç›®å½•ä¸‹æ²¡æœ‰æ‰¾åˆ° MP4 è§†é¢‘")
        except Exception as e:
            self.window.append_log(f"âŒ æ‰«æç›®å½•å‡ºé”™: {e}")

    def on_dir_changed(self):
        self.window.append_log(f"ğŸ“‚ ç›®å½•å·²å˜æ›´: {self.window.current_save_dir}")
        self.dl_manager.save_dir = self.window.current_save_dir
        self.window.table.setRowCount(0)
        self.videos.clear()
        self.scan_local_dir()
    def on_rename_video(self, item):
        """å¤„ç†è¡¨æ ¼é‡å‘½å"""
        # åªæœ‰ç¬¬ä¸€åˆ—(æ ‡é¢˜)å˜åŒ–æ‰å¤„ç†
        if item.column() != 0: return
        vid = item.data(Qt.ItemDataRole.UserRole)
        if not vid or vid not in self.videos: return
        video = self.videos[vid]
        new_title = item.text().strip()
        # å¦‚æœæ ‡é¢˜æ²¡å˜ï¼Œæˆ–è€…æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå¿½ç•¥
        if new_title == video.title: return
        if not os.path.exists(video.local_path):
            # å›æ»š UI
            self.window.table.blockSignals(True)
            item.setText(video.title)
            self.window.table.blockSignals(False)
            return
        # æ‰§è¡Œæ–‡ä»¶é‡å‘½å
        try:
            old_path = video.local_path
            dir_name = os.path.dirname(old_path)
            # ç¡®ä¿æ–°æ–‡ä»¶ååˆæ³•
            safe_name = sanitize_filename(new_title) + ".mp4"
            new_path = os.path.join(dir_name, safe_name)
            if new_path != old_path:
                # [å…³é”®] å¦‚æœæ­£åœ¨æ’­æ”¾è¯¥è§†é¢‘ï¼Œå…ˆé‡Šæ”¾å¥æŸ„
                if self.current_playing_id == vid:
                    self.window.player.setSource(QUrl())
                os.rename(old_path, new_path)
                # æ›´æ–°å†…å­˜å¯¹è±¡
                video.title = new_title
                video.local_path = new_path
                self.window.append_log(f"ğŸ“ é‡å‘½åæˆåŠŸ: {safe_name}")
                # å¦‚æœåˆšæ‰è¢«è¿«åœæ­¢äº†æ’­æ”¾ï¼Œé‡æ–°åŠ è½½æ–°è·¯å¾„
                if self.current_playing_id == vid:
                    self.play_video(vid)
        except OSError as e:
            # å¤±è´¥å›æ»š
            self.window.table.blockSignals(True)
            item.setText(video.title)
            self.window.table.blockSignals(False)
            self.window.append_log(f"âŒ é‡å‘½åå¤±è´¥: {e}")
            QMessageBox.warning(self.window, "é”™è¯¯", f"é‡å‘½åæ–‡ä»¶å¤±è´¥:\n{e}")
    def delete_video(self, row, vid):
        """åˆ é™¤è§†é¢‘ (UI -> Controller -> FileSystem)"""
        video = self.videos.get(vid)
        if not video: return
        reply = QMessageBox.question(
            self.window, 'ç¡®è®¤åˆ é™¤',
            f"ç¡®å®šè¦åˆ é™¤ '{video.title}' å—ï¼Ÿ\næœ¬åœ°æ–‡ä»¶å°†è¢«æ°¸ä¹…ç§»é™¤ã€‚",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        if reply == QMessageBox.StandardButton.No: return
        # 1. é‡Šæ”¾æ–‡ä»¶å ç”¨
        # å¦‚æœå½“å‰æ­£åœ¨æ’­æ”¾è¿™ä¸ªè§†é¢‘ï¼Œå¿…é¡»å…ˆè®©æ’­æ”¾å™¨åœæ­¢å¹¶åŠ è½½ç©ºæº
        if self.current_playing_id == vid:
            self.window.player.stop()
            self.window.player.setSource(QUrl())  # é‡Šæ”¾æ–‡ä»¶é”
            self.current_playing_id = None
            self.window.vid_w.update()  # åˆ·æ–°é»‘å±
            time.sleep(0.1)  # ç»™ç³»ç»Ÿä¸€ç‚¹æ—¶é—´é‡Šæ”¾å¥æŸ„
        # 2. å°è¯•ç‰©ç†åˆ é™¤
        if video.local_path and os.path.exists(video.local_path):
            try:
                os.remove(video.local_path)
                self.window.append_log(f"ğŸ—‘ï¸ å·²åˆ é™¤æ–‡ä»¶: {os.path.basename(video.local_path)}")
            except OSError as e:
                self.window.append_log(f"âŒ åˆ é™¤æ–‡ä»¶å¤±è´¥: {e}")
                QMessageBox.critical(self.window, "åˆ é™¤å¤±è´¥", f"æ— æ³•åˆ é™¤æ–‡ä»¶ (å¯èƒ½è¢«å ç”¨):\n{e}")
                return  # åˆ é™¤å¤±è´¥åˆ™ä¸æ›´æ–° UI
        # 3. åªæœ‰æ–‡ä»¶åˆ é™¤äº†ï¼Œæ‰æ›´æ–° UI å’Œå†…å­˜
        self.window.table.removeRow(row)
        if vid in self.videos:
            del self.videos[vid]
        # 4. æŒ‰é’®é”™ä½é—®é¢˜
        self.window.refresh_table_bindings()
    # ---------------- çˆ¬è™«æ§åˆ¶ ----------------
    def start_crawl(self, keyword, plugin_id, options):
        plugin = registry.get_plugin(plugin_id)
        if not plugin: return
        self.window.append_log(f"ğŸŸ¢ å¯åŠ¨ä»»åŠ¡ | æ¨¡å¼: {plugin.name}")
        # MissAV ä¾èµ–æ£€æŸ¥
        if plugin_id == "missav" and not os.path.exists("N_m3u8DL-RE.exe"):
            QMessageBox.critical(self.window, "ç¼ºå¤±ä¾èµ–", "æœªæ‰¾åˆ° N_m3u8DL-RE.exe")
            self.reset_ui_state()
            return
        # åœæ­¢æ—§ä»»åŠ¡
        if self.current_spider and self.current_spider.isRunning():
            self.current_spider.stop()
            self.current_spider.wait()
        # åˆ›å»ºæ–°çˆ¬è™«
        SpiderClass = plugin.get_spider_class()
        self.current_spider = SpiderClass(keyword, options)
        # è¿æ¥ä¿¡å·
        self.current_spider.sig_log.connect(self.window.append_log)
        self.current_spider.sig_item_found.connect(self.on_video_found)
        self.current_spider.sig_finished.connect(self.on_spider_finished)
        # [æ ¸å¿ƒ] è¿æ¥å¼¹çª—è¯·æ±‚ä¿¡å·
        self.current_spider.sig_select_tasks.connect(self.on_spider_select_tasks)
        self.current_spider.start()
    def on_spider_select_tasks(self, items):
        # å“åº”çˆ¬è™«å‘æ¥çš„â€œè¯·è®©ç”¨æˆ·é€‰æ‹©â€è¯·æ±‚
        # å¼¹å‡º UI å¯¹è¯æ¡† (é˜»å¡ä¸»çº¿ç¨‹ï¼Œç›´åˆ°ç”¨æˆ·å…³é—­å¼¹çª—)
        selected_indices = self.window.show_selection_dialog(items)
        # å°†ç»“æœä¼ å›ç»™çˆ¬è™«çº¿ç¨‹ (è§£é™¤çˆ¬è™«çš„é˜»å¡)
        if self.current_spider:
            self.current_spider.resume_from_ui(selected_indices)
    def stop_crawl(self):
        if self.current_spider:
            self.current_spider.stop()
            self.window.append_log("ğŸ›‘ æ­£åœ¨åœæ­¢çˆ¬è™«...")
    def on_spider_finished(self):
        self.window.append_log("ğŸ çˆ¬è™«ä»»åŠ¡ç»“æŸ")
        self.reset_ui_state()
        self.current_spider = None
    def reset_ui_state(self):
        self.window.btn_start.setEnabled(True)
        self.window.btn_stop.setEnabled(False)
        self.window.inp_search.setEnabled(True)
        self.window.combo_source.setEnabled(True)
        if self.window.plugin_widget: self.window.plugin_widget.setEnabled(True)

    def on_video_found(self, video_item):
        save_path = self.window.current_save_dir
        if "folder_name" in video_item.meta:
            folder_name = video_item.meta["folder_name"]
            # ç¡®ä¿ folder_name æœ‰æ•ˆ
            if folder_name and folder_name.strip():
                sub_dir = os.path.join(save_path, folder_name)
                if not os.path.exists(sub_dir):
                    try:
                        os.makedirs(sub_dir)
                    except:
                        pass
                save_path = sub_dir
                # æ›´æ–° UI æç¤º
                self.window.lbl_full_path.setText(save_path)
                self.window.lbl_full_path.setToolTip(save_path)
        self.videos[video_item.id] = video_item
        self.window.add_video_row(video_item)
        self.dl_manager.add_task(video_item, save_path)
    # ---------------- ä¸‹è½½å›è°ƒ ----------------
    def on_dl_start(self, vid):
        if vid in self.videos:
            self.videos[vid].status = "downloading"
            self.window.update_video_status(vid, "â¬‡ï¸ ä¸‹è½½ä¸­")
    def on_dl_progress(self, vid, percent):
        if vid in self.videos:
            self.videos[vid].progress = percent
            self.window.update_video_status(vid, "â¬‡ï¸ ä¸‹è½½ä¸­", percent)
    def on_dl_finish(self, vid):
        if vid in self.videos:
            self.videos[vid].status = "finished"
            self.videos[vid].progress = 100
            self.window.update_video_status(vid, "âœ… å®Œæˆ", 100)
            self.window.append_log(f"ğŸ‰ ä¸‹è½½å®Œæˆ: {self.videos[vid].title}")
    def on_dl_error(self, vid, msg):
        if vid in self.videos:
            self.videos[vid].status = "error"
            self.window.update_video_status(vid, "âŒ å¤±è´¥")
            self.window.append_log(f"âŒ ä¸‹è½½å‡ºé”™ [{self.videos[vid].title}]: {msg}")
    def play_video(self, vid):
        video = self.videos.get(vid)
        if not video or not os.path.exists(video.local_path):
            self.window.append_log("âŒ æ–‡ä»¶ä¸å­˜åœ¨æˆ–å·²è¢«åˆ é™¤")
            return
        self.current_playing_id = vid
        self.window.append_log(f"â–¶ï¸ æ’­æ”¾: {video.title}")
        self.window.player.setSource(QUrl.fromLocalFile(video.local_path))
        self.window.player.play()
        # åˆ‡æ¢å›¾æ ‡
        self.window.btn_play.setIcon(self.window.style().standardIcon(self.window.style().StandardPixmap.SP_MediaPause))
    def run(self):
        sys.exit(self.app.exec())

if __name__ == "__main__":
    controller = ApplicationController()
    controller.run()